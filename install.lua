-- Arcade OS Installer
-- Generated by bundle.ps1

local function ensureDirForPath(path)
    local dir = fs.getDir(path)
    if dir and dir ~= '' and not fs.exists(dir) then
        fs.makeDir(dir)
    end
end

local function writeFile(path, content)
    ensureDirForPath(path)
    local file = fs.open(path, 'w')
    file.write(content)
    file.close()
    print('Installed: ' .. path)
end

print('Installing Arcade OS...')
writeFile('audio.lua', [[
-- audio.lua
-- Simple Audio Manager for Arcade Games
-- Provides DOS-esque sound effects using the Speaker peripheral

local audio = {}
local speaker = peripheral.find("speaker")

-- Helper to play a note safely
local function play(instrument, volume, pitch)
    if speaker then
        speaker.playNote(instrument, volume, pitch)
    end
end

-- Sound Effects

function audio.playClick()
    -- Simple UI click
    play("hat", 0.5, 24)
end

function audio.playConfirm()
    -- Selection confirmation
    play("bit", 1, 14)
end

function audio.playWin()
    -- Victory jingle
    if not speaker then return end
    play("bit", 2, 12)
    sleep(0.1)
    play("bit", 2, 16)
    sleep(0.1)
    play("bit", 2, 19)
    sleep(0.1)
    play("bit", 2, 24)
end

function audio.playLose()
    -- Losing sound
    if not speaker then return end
    play("bit", 2, 12)
    sleep(0.15)
    play("bit", 2, 8)
    sleep(0.15)
    play("bit", 2, 4)
end

function audio.playShuffle()
    -- Card shuffling / Slot spinning tick
    play("snare", 0.5, 24)
end

function audio.playDeal()
    -- Card dealing sound
    play("hat", 1, 16)
end

function audio.playSlotStop()
    -- Slot reel stopping
    play("basedrum", 2, 16)
end

function audio.playChip()
    -- Chip betting sound
    play("hat", 1, 12)
end

function audio.playCashRegister()
    -- Cha-ching!
    if not speaker then return end
    play("bell", 2, 12)
    sleep(0.1)
    play("bell", 2, 16)
end

function audio.playCoinDispense()
    -- Clinking coins
    if not speaker then return end
    for i = 1, 3 do
        play("bit", 1, 20 + math.random(-2, 2))
        sleep(0.05)
    end
end

function audio.playError()
    -- Error buzzer
    if not speaker then return end
    play("bass", 2, 6)
    sleep(0.1)
    play("bass", 2, 6)
end

function audio.playDFPWM(path, volume)
    -- Plays a DFPWM file
    if not speaker then return false end
    if not fs.exists(path) then return false end

    local dfpwm = require("cc.audio.dfpwm")
    local decoder = dfpwm.make_decoder()
    
    local file = fs.open(path, "rb")
    if not file then return false end

    -- Read in chunks
    while true do
        local chunk = file.read(16 * 1024)
        if not chunk then break end
        
        local buffer = decoder(chunk)
        
        while not speaker.playAudio(buffer, volume or 1.0) do
            os.pullEvent("speaker_audio_empty")
        end
    end
    
    file.close()
    return true
end

return audio

]])

writeFile('blackjack.lua', [[
-- blackjack.lua
-- Sequential Multiplayer Blackjack for Arcade OS
-- Visual Overhaul

local w, h = term.getSize()
local SUITS = {"H", "D", "C", "S"}
local RANKS = {"2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"}

-- Colors
local C_TABLE = colors.green
local C_TEXT = colors.white
local C_CARD_BG = colors.white
local C_CARD_RED = colors.red
local C_CARD_BLK = colors.black
local C_HIDDEN = colors.red
local C_LABEL = colors.yellow
local C_MSG = colors.cyan

-- Card Dimensions
local CARD_W = 4
local CARD_H = 3

local input = require("input")

local function waitKey()
    while true do
        local e, p1 = os.pullEvent()
        local button = input.getButton(e, p1)
        if button then
            if e == "redstone" then sleep(0.2) end
            return button
        end
    end
end

--------------------------------------------------------------------------------
-- GAME LOGIC
--------------------------------------------------------------------------------

local function createDeck()
    local deck = {}
    for _, s in ipairs(SUITS) do
        for _, r in ipairs(RANKS) do
            table.insert(deck, {suit=s, rank=r})
        end
    end
    -- Shuffle
    for i = #deck, 2, -1 do
        local j = math.random(i)
        deck[i], deck[j] = deck[j], deck[i]
    end
    return deck
end

local function getCardValue(card)
    if card.rank == "A" then return 11 end
    if card.rank == "K" or card.rank == "Q" or card.rank == "J" then return 10 end
    return tonumber(card.rank)
end

local function calculateHand(hand)
    local total = 0
    local aces = 0
    for _, card in ipairs(hand) do
        total = total + getCardValue(card)
        if card.rank == "A" then aces = aces + 1 end
    end
    while total > 21 and aces > 0 do
        total = total - 10
        aces = aces - 1
    end
    return total
end

local function drawCardDeck(deck)
    if #deck == 0 then deck = createDeck() end -- Reshuffle if empty
    return table.remove(deck, 1)
end

--------------------------------------------------------------------------------
-- UI
--------------------------------------------------------------------------------



local function animateSparkles(x, y, width, height)
    local duration = 1.5
    local startTime = os.clock()
    local colorsList = {colors.yellow, colors.gold or colors.orange, colors.white}
    
    while os.clock() - startTime < duration do
        local rx = math.random(x, x + width - 1)
        local ry = math.random(y, y + height - 1)
        local color = colorsList[math.random(1, #colorsList)]
        
        term.setCursorPos(rx, ry)
        term.setTextColor(color)
        term.write("*")
        
        sleep(0.05)
    end
end

local function animateChips(startX, startY, endX, endY)
    local steps = 10
    local dx = (endX - startX) / steps
    local dy = (endY - startY) / steps
    
    for i = 1, steps do
        local cx = math.floor(startX + dx * i)
        local cy = math.floor(startY + dy * i)
        
        -- Draw Chip
        term.setCursorPos(cx, cy)
        term.setBackgroundColor(colors.yellow)
        term.setTextColor(colors.black)
        term.write("O")
        
        sleep(0.05)
        
        -- Clear Chip (simple clear, might overwrite background)
        term.setCursorPos(cx, cy)
        term.setBackgroundColor(colors.green) -- Assuming table color
        term.write(" ")
    end
end

local function drawText(x, y, text, fg, bg)
    term.setCursorPos(x, y)
    if fg then term.setTextColor(fg) end
    if bg then term.setBackgroundColor(bg) end
    term.write(text)
end

local function drawCenter(y, text, fg, bg)
    local x = math.floor((w - #text)/2) + 1
    drawText(x, y, text, fg, bg)
end

local function getSuitColor(suit)
    if suit == "H" or suit == "D" then return C_CARD_RED else return C_CARD_BLK end
end

local function getSuitChar(suit)
    -- If using a font that supports symbols, we could use them.
    -- Standard CC font doesn't have suit symbols, so we use letters.
    return suit
end

local function drawGraphicalCard(x, y, card, hidden)
    -- Card Background
    term.setBackgroundColor(hidden and C_HIDDEN or C_CARD_BG)
    
    for i=0, CARD_H-1 do
        term.setCursorPos(x, y+i)
        term.write(string.rep(" ", CARD_W))
    end
    
    if hidden then
        -- Pattern for hidden card
        term.setTextColor(colors.white)
        term.setCursorPos(x, y+1)
        term.write(" ?? ")
    else
        -- Rank and Suit
        local sColor = getSuitColor(card.suit)
        term.setTextColor(sColor)
        
        local rankStr = card.rank
        if #rankStr == 1 then rankStr = rankStr .. " " end
        
        -- Top Left
        term.setCursorPos(x, y)
        term.write(rankStr)
        
        -- Center Suit
        term.setCursorPos(x+1, y+1)
        term.write(getSuitChar(card.suit))
        
        -- Bottom Right (Rotated/Inverted conceptually, but just text here)
        term.setCursorPos(x+CARD_W-#rankStr, y+CARD_H-1)
        term.write(rankStr)
    end
end

local function drawHandGraphical(centerX, y, name, hand, hideFirst, isActive, status)
    -- Calculate total width of hand to center it
    -- Overlap cards by 1 column if hand is large?
    -- Let's do simple spacing: CARD_W + 1
    local spacing = CARD_W + 1
    local totalW = (#hand * spacing) - 1
    local startX = math.floor(centerX - totalW/2)
    
    -- Draw Name Label
    local labelColor = isActive and colors.yellow or colors.lightGray
    drawText(startX, y - 1, name, labelColor, C_TABLE)
    
    -- Draw Status if present
    if status and status ~= "Playing" then
        local sColor = colors.lightGray
        if status == "Blackjack!" or string.find(status, "WIN") then sColor = colors.gold or colors.orange end
        if status == "Bust!" or string.find(status, "LOSE") then sColor = colors.red end
        drawText(startX + #name + 2, y - 1, status, sColor, C_TABLE)
    end
    
    -- Draw Cards
    for i, card in ipairs(hand) do
        local cx = startX + (i-1)*spacing
        local isHidden = hideFirst and (i == 1)
        drawGraphicalCard(cx, y, card, isHidden)
    end
    
    -- Draw Score
    if not hideFirst then
        local score = calculateHand(hand)
        drawText(startX, y + CARD_H, "Score: " .. score, colors.gray, C_TABLE)
    end
end

local function drawTable(players, dealerHand, currentPlayerIdx, message, showDealer)
    term.setBackgroundColor(C_TABLE)
    term.clear()
    
    -- Header
    drawCenter(1, " BLACKJACK ", colors.black, colors.lime)
    
    -- Dealer Area (Top Center)
    local dealerY = 3
    drawHandGraphical(w/2, dealerY, "DEALER", dealerHand, not showDealer, false, nil)
    
    -- Player Area (Bottom)
    -- Distribute players evenly
    local playerY = h - 6 -- Leave room for controls
    local sectionW = w / #players
    
    for i, p in ipairs(players) do
        local pCenterX = (i-1)*sectionW + sectionW/2
        local isActive = (i == currentPlayerIdx)
        -- Add indicator if active
        if isActive then
            drawText(math.floor(pCenterX)-2, playerY-2, " vvv ", colors.white, C_TABLE)
        end
        drawHandGraphical(pCenterX, playerY, "P"..i, p.hand, false, isActive, p.status)
    end
    
    -- Message / Controls Area (Bottom 2 lines)
    local footerY = h - 1
    term.setBackgroundColor(colors.black)
    term.setCursorPos(1, h-1)
    term.clearLine()
    term.setCursorPos(1, h)
    term.clearLine()
    
    if message then
        drawCenter(h-1, message, C_MSG, colors.black)
    end
    
    -- Draw 3-Column Footer
    local colW = math.floor(w / 3)
    local c1 = "Hit"
    local c2 = "Stand"
    local c3 = "Shift >"
    
    if currentPlayerIdx == 0 then
        c1 = "-"
        c2 = "Deal"
        c3 = "Cash Out"
    elseif message and string.find(message, "ADV") then
        c1 = "Double"
        c2 = "Surrender"
        c3 = "Back"
    end
    
    -- Left Button
    term.setCursorPos(1, h)
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", colW))
    drawText(math.floor(colW/2 - #c1/2)+1, h, c1, colors.white, colors.red)
    
    -- Center Button
    term.setCursorPos(colW + 1, h)
    term.setBackgroundColor(colors.yellow)
    term.setTextColor(colors.black)
    term.write(string.rep(" ", colW))
    drawText(colW + math.floor(colW/2 - #c2/2)+1, h, c2, colors.black, colors.yellow)
    
    -- Right Button
    term.setCursorPos(colW * 2 + 1, h)
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", w - (colW*2)))
    drawText(colW*2 + math.floor((w - colW*2)/2 - #c3/2)+1, h, c3, colors.white, colors.blue)
end

local function waitForBreakEvent(seconds)
    local timerId
    if seconds and seconds > 0 then
        timerId = os.startTimer(seconds)
    end

    while true do
        local e, p1 = os.pullEvent()

        if e == "disk" then
            return { type = "disk", event = e, p1 = p1 }
        end
        if e == "disk_eject" then
            return { type = "disk_eject", event = e, p1 = p1 }
        end

        local button = input.getButton(e, p1)
        if button then
            return { type = "button", button = button, event = e, p1 = p1 }
        end

        if e == "key" or e == "char" then
            return { type = "key", event = e, p1 = p1 }
        end

        if timerId and e == "timer" and p1 == timerId then
            return { type = "timeout" }
        end
    end
end

local function runAttractMode()
    local function cpuWantsHit(hand)
        local score = calculateHand(hand)
        if score <= 11 then return true end
        if score >= 17 then return false end
        return score < 16
    end

    while true do
        local players = {
            { hand = {}, status = "Playing", name = "CPU 1" },
            { hand = {}, status = "Playing", name = "CPU 2" },
            { hand = {}, status = "Playing", name = "CPU 3" }
        }

        local deck = createDeck()
        local dealerHand = {}

        -- Initial deal
        for _ = 1, 2 do
            for _, p in ipairs(players) do
                table.insert(p.hand, drawCardDeck(deck))
                drawTable(players, dealerHand, 0, "ATTRACTION MODE - Insert Disk to Play", false)
                local brk = waitForBreakEvent(0.15)
                if brk and brk.type == "disk" then return brk end
            end

            table.insert(dealerHand, drawCardDeck(deck))
            drawTable(players, dealerHand, 0, "ATTRACTION MODE - Insert Disk to Play", false)
            local brk = waitForBreakEvent(0.15)
            if brk and brk.type == "disk" then return brk end
        end

        -- CPU turns
        for i, p in ipairs(players) do
            while true do
                local score = calculateHand(p.hand)
                if score == 21 and #p.hand == 2 then
                    p.status = "Blackjack!"
                    break
                elseif score > 21 then
                    p.status = "Bust!"
                    break
                end

                if cpuWantsHit(p.hand) then
                    table.insert(p.hand, drawCardDeck(deck))
                    drawTable(players, dealerHand, i, "ATTRACTION MODE - " .. p.name .. " hits", false)
                    local brk = waitForBreakEvent(0.35)
                    if brk and brk.type == "disk" then return brk end
                else
                    p.status = "Stand"
                    drawTable(players, dealerHand, i, "ATTRACTION MODE - " .. p.name .. " stands", false)
                    local brk = waitForBreakEvent(0.35)
                    if brk and brk.type == "disk" then return brk end
                    break
                end
            end
        end

        -- Dealer turn
        drawTable(players, dealerHand, 0, "ATTRACTION MODE - Dealer reveals", true)
        local brk = waitForBreakEvent(0.8)
        if brk and brk.type == "disk" then return brk end

        while calculateHand(dealerHand) < 17 do
            table.insert(dealerHand, drawCardDeck(deck))
            drawTable(players, dealerHand, 0, "ATTRACTION MODE - Dealer hits", true)
            brk = waitForBreakEvent(0.6)
            if brk and brk.type == "disk" then return brk end
        end

        -- Resolve (no credits; just show outcomes)
        local dealerScore = calculateHand(dealerHand)
        local dealerBust = dealerScore > 21

        for _, p in ipairs(players) do
            local pScore = calculateHand(p.hand)
            if p.status == "Bust!" then
                p.status = "LOSE"
            elseif p.status == "Blackjack!" then
                p.status = "WIN!"
            elseif dealerBust then
                p.status = "WIN!"
            elseif pScore > dealerScore then
                p.status = "WIN!"
            elseif pScore == dealerScore then
                p.status = "PUSH"
            else
                p.status = "LOSE"
            end
        end

        drawTable(players, dealerHand, 0, "ATTRACTION MODE - Round over (Insert Disk)", true)
        brk = waitForBreakEvent(2.0)
        if brk and brk.type == "disk" then return brk end

        -- Small pause before next round
        brk = waitForBreakEvent(0.6)
        if brk and brk.type == "disk" then return brk end
    end
end

--------------------------------------------------------------------------------
-- MAIN LOOP
--------------------------------------------------------------------------------

local function main()
    term.setBackgroundColor(colors.black)
    term.clear()
    
    local creditsAPI = require("credits")
    local audio = require("audio")
    
    while true do
        drawCenter(h/2 - 2, "BLACKJACK", colors.lime, colors.black)
        drawCenter(h/2, "Insert Cards (Max 3)", colors.white, colors.black)
        drawCenter(h/2 + 2, "[C] Start Game   [R] Exit", colors.gray, colors.black)
        
        -- Lobby Loop
        local detectedCards = {}
        local attractDelay = 8
        local attractTimer = os.startTimer(attractDelay)
        while true do
            local event, p1 = os.pullEvent()

            if event == "timer" and p1 == attractTimer and #detectedCards == 0 then
                -- CPU vs CPU demo until a disk is inserted (attract mode)
                runAttractMode()

                -- Redraw lobby after attract mode
                term.setBackgroundColor(colors.black)
                term.clear()
                drawCenter(h/2 - 2, "BLACKJACK", colors.lime, colors.black)
                drawCenter(h/2, "Insert Cards (Max 3)", colors.white, colors.black)
                drawCenter(h/2 + 2, "[C] Start Game   [R] Exit", colors.gray, colors.black)

                -- Refresh cards and reset timer
                detectedCards = creditsAPI.findCards()
                attractTimer = os.startTimer(attractDelay)
            end

            -- Arcade button controls (works for redstone + key-based configs)
            local button = input.getButton(event, p1)
            if button == "CENTER" then
                if #detectedCards > 0 then break end
                drawCenter(h/2 + 4, "No players detected!", colors.red, colors.black)
                sleep(1)
                term.setCursorPos(1, h/2+4) term.clearLine()
                attractTimer = os.startTimer(attractDelay)
            elseif button == "RIGHT" then
                term.setBackgroundColor(colors.black)
                term.clear()
                if fs.exists("menu.lua") then shell.run("menu.lua") end
                return
            end

            if event == "key" then
                local key = keys.getName(p1)
                if key == "enter" or key == "space" then -- Start
                    if #detectedCards > 0 then break end
                    drawCenter(h/2 + 4, "No players detected!", colors.red, colors.black)
                    sleep(1)
                    term.setCursorPos(1, h/2+4) term.clearLine()
                    attractTimer = os.startTimer(attractDelay)
                elseif key == "backspace" or key == "e" then -- Exit
                     term.setBackgroundColor(colors.black)
                     term.clear()
                     if fs.exists("menu.lua") then shell.run("menu.lua") end
                     return
                end
            elseif event == "disk" or event == "disk_eject" then
                -- Refresh cards
                detectedCards = creditsAPI.findCards()
                attractTimer = os.startTimer(attractDelay)
                term.setCursorPos(1, h/2 + 4)
                term.clearLine()
                local msg = "Players: "
                for i, c in ipairs(detectedCards) do
                    msg = msg .. c.name .. " "
                end
                drawCenter(h/2 + 4, msg, colors.yellow, colors.black)
            end
            
            -- Initial scan if just opened
            if #detectedCards == 0 then
                 detectedCards = creditsAPI.findCards()
                 if #detectedCards > 0 then
                    attractTimer = os.startTimer(attractDelay)
                    term.setCursorPos(1, h/2 + 4)
                    term.clearLine()
                    local msg = "Players: "
                    for i, c in ipairs(detectedCards) do
                        msg = msg .. c.name .. " "
                    end
                    drawCenter(h/2 + 4, msg, colors.yellow, colors.black)
                end
            end
        end
        
        -- Limit to 3 players
        local players = {}
        for i, card in ipairs(detectedCards) do
            if i > 3 then break end
            creditsAPI.lock(card.path)
            table.insert(players, {
                hand={}, 
                status="Playing", 
                bet=10, 
                name=card.name, -- Use card name
                mountPath=card.path 
            })
            if creditsAPI.get(card.path) < 10 then
                drawCenter(h/2, card.name .. " needs 10 credits!", colors.red, colors.black)
                creditsAPI.unlock(card.path)
                sleep(2)
                return -- Go back to lobby effectively (restarts main)
            end
            creditsAPI.remove(10, card.path) -- Deduct bet immediately
        end
        
        local deck = createDeck()
        local dealerHand = {}
        
        -- Initial Deal
        for _=1,2 do
            for _, p in ipairs(players) do 
                table.insert(p.hand, drawCardDeck(deck)) 
                audio.playDeal()
                sleep(0.2)
            end
            table.insert(dealerHand, drawCardDeck(deck))
            audio.playDeal()
            sleep(0.2)
        end
        
        -- Player Turns
        for i, p in ipairs(players) do
            while true do
                local score = calculateHand(p.hand)
                if score == 21 and #p.hand == 2 then
                    p.status = "Blackjack!"
                    break
                elseif score > 21 then
                    p.status = "Bust!"
                    break
                end
                
                drawTable(players, dealerHand, i, p.name .. "'s Turn", false)
                local action = waitKey()
                
                -- Normal Mode
                if action == "LEFT" then -- Hit
                    table.insert(p.hand, drawCardDeck(deck))
                    audio.playDeal()
                elseif action == "CENTER" then -- Stand
                    p.status = "Stand"
                    break
                elseif action == "RIGHT" then -- Shift (Advanced Mode)
                    -- Show Advanced Options
                    drawTable(players, dealerHand, i, "ADV: [L] Dbl [C] Surr [R] Back", false)
                    local advAction = waitKey()
                    
                    if advAction == "LEFT" then -- Double Down
                        if creditsAPI.get(p.mountPath) >= p.bet then
                            creditsAPI.remove(p.bet, p.mountPath)
                            p.bet = p.bet * 2
                            table.insert(p.hand, drawCardDeck(deck))
                            audio.playDeal()
                            score = calculateHand(p.hand)
                            if score > 21 then p.status = "Bust!" else p.status = "Dbl Stand" end
                            break
                        else
                             drawTable(players, dealerHand, i, "Not enough credits!", false)
                             sleep(1)
                        end
                    elseif advAction == "CENTER" then -- Surrender
                         p.status = "Surrender"
                         break
                    elseif advAction == "RIGHT" then -- Back
                        -- Loop continues
                    end
                end
            end
            drawTable(players, dealerHand, i, p.name .. " Done", false)
            sleep(0.5)
        end
        
        -- Dealer Turn
        drawTable(players, dealerHand, 0, "Dealer's Turn...", true)
        sleep(1)
        while calculateHand(dealerHand) < 17 do
            table.insert(dealerHand, drawCardDeck(deck))
            audio.playDeal()
            drawTable(players, dealerHand, 0, "Dealer Hits...", true)
            sleep(1)
        end
        
        -- Resolve
        local dealerScore = calculateHand(dealerHand)
        local dealerBust = dealerScore > 21
        
        for _, p in ipairs(players) do
            local pScore = calculateHand(p.hand)
            if p.status == "Bust!" then
                p.status = "LOSE"
            elseif p.status == "Surrender" then
                p.status = "SURRENDER"
                creditsAPI.add(math.floor(p.bet / 2), p.mountPath)
            elseif p.status == "Blackjack!" then
                 p.status = "WIN!"
                 creditsAPI.add(math.floor(p.bet * 2.5), p.mountPath) -- 3:2 payout usually, but let's do 2.5x return
            elseif dealerBust then
                p.status = "WIN!"
                creditsAPI.add(p.bet * 2, p.mountPath)
            elseif pScore > dealerScore then
                p.status = "WIN!"
                creditsAPI.add(p.bet * 2, p.mountPath)
            elseif pScore == dealerScore then
                p.status = "PUSH"
                creditsAPI.add(p.bet, p.mountPath)
            else
                p.status = "LOSE"
            end
            
            -- Unlock card
            creditsAPI.unlock(p.mountPath)
        end
        
        drawTable(players, dealerHand, 0, "Round Over!", true)
        
        -- Play Animations for Winners
        local sectionW = w / #players
        local playerY = h - 6
        local dealerX, dealerY = w/2, 3
        
        for i, p in ipairs(players) do
            if p.status == "WIN!" or p.status == "Blackjack!" then
                local pCenterX = math.floor((i-1)*sectionW + sectionW/2)
                
                -- Animate Chips from Dealer to Player
                audio.playChip()
                animateChips(dealerX, dealerY, pCenterX, playerY)
                audio.playWin()
                
                -- Animate Sparkles around Player
                animateSparkles(pCenterX - 6, playerY - 2, 12, 6)
                
                drawTable(players, dealerHand, 0, "Round Over!", true) -- Redraw to clear noise
            end
        end
        
        drawTable(players, dealerHand, 0, "Round Over! [C] Play Again", true)
        
        local endAction = waitKey()
        if endAction == "RIGHT" then
            break
        end
    end
    
    -- Exit to Menu
    term.setBackgroundColor(colors.black)
    term.clear()
    if fs.exists("menu.lua") then shell.run("menu.lua") end
end

main()

]])

writeFile('cant_stop.lua', [=[
-- cant_stop.lua
-- A push-your-luck dice game for the Arcade OS

local w, h = term.getSize()
local cx, cy = math.floor(w / 2), math.floor(h / 2)

-- 3-Button Config
local input = require("input")
local audio = require("audio")

local function refreshSize()
    w, h = term.getSize()
    cx, cy = math.floor(w / 2), math.floor(h / 2)
end

--------------------------------------------------------------------------------
-- UI PRIMITIVES (direct draw)
--------------------------------------------------------------------------------

local HAS_BLIT = type(term.blit) == "function" and type(colors) == "table" and type(colors.toBlit) == "function"

local function clamp(n, lo, hi)
    if n < lo then return lo end
    if n > hi then return hi end
    return n
end

local function toBlit(c)
    if not HAS_BLIT then return "0" end
    return colors.toBlit(c)
end

local function fillRect(x, y, width, height, bg, fg, ch)
    if width <= 0 or height <= 0 then return end
    ch = ch or " "
    bg = bg or colors.black
    fg = fg or colors.white

    if HAS_BLIT then
        local text = string.rep(ch, width)
        local fgs = string.rep(toBlit(fg), width)
        local bgs = string.rep(toBlit(bg), width)
        for row = 0, height - 1 do
            term.setCursorPos(x, y + row)
            term.blit(text, fgs, bgs)
        end
    else
        term.setBackgroundColor(bg)
        term.setTextColor(fg)
        for row = 0, height - 1 do
            term.setCursorPos(x, y + row)
            term.write(string.rep(ch, width))
        end
    end
end

local function writeAt(x, y, text, fg, bg)
    if not text or #text == 0 then return end
    term.setCursorPos(x, y)
    if HAS_BLIT and fg and bg then
        term.blit(text, string.rep(toBlit(fg), #text), string.rep(toBlit(bg), #text))
        return
    end
    if bg then term.setBackgroundColor(bg) end
    if fg then term.setTextColor(fg) end
    term.write(text)
end

local function centerText(x, y, width, text, fg, bg)
    local tx = x + math.floor((width - #text) / 2)
    writeAt(tx, y, text, fg, bg)
end

local function frameRect(x, y, width, height, borderBg, innerBg)
    if width <= 1 or height <= 1 then return end
    borderBg = borderBg or colors.gray
    innerBg = innerBg or colors.black
    fillRect(x, y, width, 1, borderBg)
    fillRect(x, y + height - 1, width, 1, borderBg)
    fillRect(x, y + 1, 1, height - 2, borderBg)
    fillRect(x + width - 1, y + 1, 1, height - 2, borderBg)
    fillRect(x + 1, y + 1, width - 2, height - 2, innerBg)
end

local function drawTitleBar(title, rightText)
    local w2, _ = term.getSize()
    fillRect(1, 1, w2, 1, colors.blue)
    writeAt(2, 1, title, colors.yellow, colors.blue)
    if rightText then
        writeAt(math.max(1, w2 - #rightText), 1, rightText, colors.white, colors.blue)
    end
end

local function drawButtonBar(leftText, centerTextLabel, rightText)
    local w2, h2 = term.getSize()
    local colW = math.floor(w2 / 3)
    local leftW = colW
    local midW = colW
    local rightW = w2 - (colW * 2)

    local function fit(text, width)
        text = text or ""
        if width <= 0 then return "" end
        if #text > width then
            return text:sub(1, width)
        end
        return text
    end

    fillRect(1, h2, leftW, 1, colors.red)
    fillRect(leftW + 1, h2, midW, 1, colors.yellow)
    fillRect(leftW + midW + 1, h2, rightW, 1, colors.blue)

    centerText(1, h2, leftW, fit(leftText, leftW), colors.white, colors.red)
    centerText(leftW + 1, h2, midW, fit(centerTextLabel, midW), colors.black, colors.yellow)
    centerText(leftW + midW + 1, h2, rightW, fit(rightText, rightW), colors.white, colors.blue)
end

local function isDedicatedCantStopMachine()
    if not fs.exists(".arcade_config") then return false end
    local f = fs.open(".arcade_config", "r")
    if not f then return false end
    local cmd = (f.readAll() or "")
    f.close()
    cmd = cmd:gsub("%s+", "")
    return cmd == "cant_stop"
end

local DEDICATED = isDedicatedCantStopMachine()

local function nowMillis()
    if type(os.epoch) == "function" then
        return os.epoch("utc")
    end
    return math.floor((os.clock() or 0) * 1000)
end

local function waitKey(tickInterval)
    local resizeTimer = os.startTimer(0.5)
    local tickTimer = nil
    if tickInterval and tickInterval > 0 then
        tickTimer = os.startTimer(tickInterval)
    end
    while true do
        local e, p1 = os.pullEvent()
        local button = input.getButton(e, p1)
        if button then
            if e == "redstone" then sleep(0.2) end
            return button
        end

        -- Poll size changes (and also react to CC's resize event)
        if e == "term_resize" then
            refreshSize()
            return "RESIZE"
        elseif e == "timer" and tickTimer and p1 == tickTimer then
            return "TICK"
        elseif e == "timer" and p1 == resizeTimer then
            local oldW, oldH = w, h
            refreshSize()
            resizeTimer = os.startTimer(0.5)
            if w ~= oldW or h ~= oldH then
                return "RESIZE"
            end
        end

        -- Keyboard exit (spawn-friendly / dev-friendly)
        if e == "key" and keys.getName(p1) == "backspace" then
            return "EXIT"
        elseif e == "char" and tostring(p1):lower() == "e" then
            return "EXIT"
        elseif e == "terminate" then
            return "EXIT"
        end
    end
end

--------------------------------------------------------------------------------
-- GAME LOGIC
--------------------------------------------------------------------------------

local COL_LENGTHS = {
    [2]=3, [3]=5, [4]=7, [5]=9, [6]=11,
    [7]=13,
    [8]=11, [9]=9, [10]=7, [11]=5, [12]=3
}

local board = {} -- [col] = {p1=0, p2=0, owner=nil}
for i=2,12 do board[i] = {p1=0, p2=0, owner=nil} end

local currentPlayer = 1
local tempMarkers = {} -- [col] = current_step
local runnersUsed = 0
local MAX_RUNNERS = 3

local function rollDice()
    local d = {}
    for i=1,4 do table.insert(d, math.random(1,6)) end
    return d
end

local function getPairings(dice)
    -- 3 ways to pair 4 dice: (1+2, 3+4), (1+3, 2+4), (1+4, 2+3)
    local pairs = {
        { {dice[1], dice[2]}, {dice[3], dice[4]} },
        { {dice[1], dice[3]}, {dice[2], dice[4]} },
        { {dice[1], dice[4]}, {dice[2], dice[3]} }
    }
    -- Calculate sums
    local options = {}
    for _, p in ipairs(pairs) do
        local s1 = p[1][1] + p[1][2]
        local s2 = p[2][1] + p[2][2]
        table.insert(options, {s1, s2})
    end
    return options
end

local function canAdvance(col)
    if board[col].owner then return false end
    if runnersUsed >= MAX_RUNNERS and not tempMarkers[col] then
        -- Check if we have a base marker here? No, runners must be placed.
        -- If we have a base marker but no runner, we need a runner to advance.
        return false
    end
    -- Check if already at top
    local current = tempMarkers[col] or (currentPlayer == 1 and board[col].p1 or board[col].p2)
    if current >= COL_LENGTHS[col] then return false end
    return true
end

local function isValidOption(opt)
    -- An option is valid if at least one of the sums can be played
    return canAdvance(opt[1]) or canAdvance(opt[2])
end

--------------------------------------------------------------------------------
-- UI
--------------------------------------------------------------------------------

local function drawText(x, y, text, fg, bg)
    writeAt(x, y, text, fg, bg)
end

local function drawBoard(showTemp)
    -- Legacy 2p renderer (kept for compatibility, but uses the new primitives)
    local w2, h2 = term.getSize()
    term.setBackgroundColor(colors.black)
    term.clear()
    drawTitleBar("CAN'T STOP", "P" .. tostring(currentPlayer) .. " TURN")

    local top = 3
    local bottom = h2 - 3
    local availH = bottom - top + 1
    local availW = w2 - 2
    local colCount = 11
    local gap = 1
    local colW = clamp(math.floor((availW - (colCount - 1)) / colCount), 3, 5)
    while colW > 3 and (2 + colCount * (colW + gap) - gap) > w2 do
        colW = colW - 1
    end
    local startX = 2

    for col = 2, 12 do
        local idx = col - 2
        local x = startX + idx * (colW + gap)
        local len = COL_LENGTHS[col]
        local owner = board[col].owner

        local ownerBg = colors.lightGray
        local ownerFg = colors.black
        if owner == 1 then ownerBg = colors.blue; ownerFg = colors.white
        elseif owner == 2 then ownerBg = colors.red; ownerFg = colors.white end

        frameRect(x, top, colW, availH, colors.gray, colors.black)
        fillRect(x + 1, top + 1, colW - 2, 1, ownerBg)
        centerText(x + 1, top + 1, colW - 2, tostring(col), ownerFg, ownerBg)

        local trackTop = top + 3
        local trackBottom = bottom - 1
        for step = 1, len do
            local y = trackBottom - (step - 1)
            if y >= trackTop and y <= trackBottom then
                fillRect(x + 1, y, colW - 2, 1, colors.gray, colors.black, " ")
            end
        end

        local p1 = board[col].p1
        local p2 = board[col].p2
        local temp = tempMarkers[col]
        local function drawMarker(step, fg, bg, ch)
            local y = trackBottom - (step - 1)
            if y < trackTop or y > trackBottom then return end
            local mx = x + math.floor(colW / 2)
            writeAt(mx, y, ch or " ", fg or colors.white, bg or colors.white)
        end

        if showTemp and temp and temp >= 1 then
            local tBg = (currentPlayer == 1) and colors.cyan or colors.orange
            drawMarker(temp, colors.black, tBg, " ")
        end
        if p1 and p1 >= 1 then drawMarker(p1, colors.black, colors.blue, " ") end
        if p2 and p2 >= 1 then
            if p1 == p2 and p1 >= 1 then
                drawMarker(p2, colors.white, colors.magenta, " ")
            else
                drawMarker(p2, colors.black, colors.red, " ")
            end
        end
    end

    fillRect(1, h2 - 2, w2, 1, colors.black)
    writeAt(2, h2 - 2, "[L/C/R] Choose  |  [E]/[Backspace] Exit", colors.gray, colors.black)
end



local function drawActionMenu()
    local w2, h2 = term.getSize()
    fillRect(1, h2 - 2, w2, 1, colors.black)
    writeAt(2, h2 - 2, "Action:", colors.white, colors.black)
    drawButtonBar("Roll Again", "Stop (Save)", "View Board")
end

--------------------------------------------------------------------------------
-- MAIN LOOP
--------------------------------------------------------------------------------

local function returnToMenu()
    term.setBackgroundColor(colors.black)
    term.clear()
    if fs.exists("menu.lua") then shell.run("menu.lua") end
end

local function runOneGame()
    -- returns true if player requested EXIT
    local numPlayers = 1

    local function runAttractModeNewGame()
        while true do
            refreshSize()
            local w2, h2 = term.getSize()
            local cx2, cy2 = math.floor(w2 / 2), math.floor(h2 / 2)

            term.setBackgroundColor(colors.black)
            term.clear()
            drawTitleBar("CAN'T STOP", "DEMO")

            frameRect(cx2 - 16, cy2 - 4, 33, 9, colors.gray, colors.black)
            centerText(cx2 - 16, cy2 - 4, 33, " ATTRACTION MODE ", colors.yellow, colors.gray)
            centerText(cx2 - 16, cy2 - 2, 33, "Rolling dice...", colors.white, colors.black)

            local dice = rollDice()
            local d = tostring(dice[1]) .. "  " .. tostring(dice[2]) .. "  " .. tostring(dice[3]) .. "  " .. tostring(dice[4])
            centerText(cx2 - 16, cy2, 33, d, colors.lime, colors.black)

            local opts = getPairings(dice)
            local o1 = tostring(opts[1][1]) .. "+" .. tostring(opts[1][2])
            local o2 = tostring(opts[2][1]) .. "+" .. tostring(opts[2][2])
            local o3 = tostring(opts[3][1]) .. "+" .. tostring(opts[3][2])
            centerText(cx2 - 16, cy2 + 2, 33, "Options: " .. o1 .. " | " .. o2 .. " | " .. o3, colors.gray, colors.black)
            centerText(cx2 - 16, cy2 + 4, 33, "Press any button to play", colors.lightGray, colors.black)

            audio.playShuffle()
            local key = waitKey(0.25)
            if key == "RESIZE" then
                -- keep looping
            elseif key ~= "TICK" then
                return key
            end
        end
    end

    while true do
        refreshSize()
        local w2, h2 = term.getSize()
        local cx2, cy2 = math.floor(w2 / 2), math.floor(h2 / 2)
        term.setBackgroundColor(colors.black)
        term.clear()
        drawTitleBar("CAN'T STOP", nil)

        frameRect(cx2 - 16, cy2 - 4, 33, 9, colors.gray, colors.black)
        centerText(cx2 - 16, cy2 - 4, 33, " NEW GAME ", colors.yellow, colors.gray)
        centerText(cx2 - 16, cy2 - 1, 33, "Players: " .. tostring(numPlayers), colors.white, colors.black)
        centerText(cx2 - 16, cy2 + 1, 33, "[L] -    [C] Start    [R] +", colors.gray, colors.black)
        centerText(cx2 - 16, cy2 + 3, 33, "[E]/[Backspace] Exit", colors.gray, colors.black)

        local key = waitKey(8)
        if key == "TICK" then
            key = runAttractModeNewGame()
        end
        if key == "RESIZE" then
            -- redraw immediately with new size
            goto continue_player_select
        end
        if key == "EXIT" then
            return true
        end
        if key == "LEFT" and numPlayers > 1 then numPlayers = numPlayers - 1 end
        if key == "RIGHT" and numPlayers < 3 then numPlayers = numPlayers + 1 end
        if key == "CENTER" then break end

        ::continue_player_select::
    end

    -- Initialize Board for N players
    for i = 2, 12 do
        board[i] = { positions = {}, owner = nil }
        for p = 1, numPlayers do
            board[i].positions[p] = 0
        end
    end

    local currentPlayer = 1

    local function drawBoardN(showTemp, dice, options, isValidOpt, modeLabel)
        local w2, h2 = term.getSize()
        term.setBackgroundColor(colors.black)
        term.clear()

        local pColorName = "Blue"
        if currentPlayer == 2 then pColorName = "Red" elseif currentPlayer == 3 then pColorName = "Green" end
        drawTitleBar("CAN'T STOP", "P" .. tostring(currentPlayer) .. " " .. pColorName)

        -- Dice strip
        fillRect(1, 2, w2, 1, colors.black)
        if dice then
            writeAt(2, 2, "Dice:", colors.gray, colors.black)
            local x = 8
            for i = 1, 4 do
                if x + 3 > w2 then break end
                local d = tostring(dice[i] or "-")
                frameRect(x, 2, 4, 1, colors.gray, colors.black)
                centerText(x, 2, 4, d, colors.white, colors.black)
                x = x + 5
            end
        end
        if modeLabel then
            writeAt(math.max(1, w2 - #modeLabel - 1), 2, modeLabel, colors.yellow, colors.black)
        end

        -- Board geometry
        local top = 3
        local bottom = h2 - 4
        local availH = bottom - top + 1
        local availW = w2 - 2
        local colCount = 11
        local gap = 1
        local colW = clamp(math.floor((availW - (colCount - 1)) / colCount), 3, 6)
        while colW > 3 and (2 + colCount * (colW + gap) - gap) > w2 do
            colW = colW - 1
        end
        local startX = 2

        local playerBg = {
            [1] = colors.blue,
            [2] = colors.red,
            [3] = colors.green,
        }

        local function flashPlayerColor(players)
            if not players or #players == 0 then return colors.magenta end
            local sec = math.floor(nowMillis() / 1000)
            local idx = (sec % #players) + 1
            return playerBg[players[idx]] or colors.magenta
        end

        for col = 2, 12 do
            local idx = col - 2
            local x = startX + idx * (colW + gap)
            local len = COL_LENGTHS[col]
            local owner = board[col].owner

            local headerBg = colors.gray
            local headerFg = colors.black
            if owner and playerBg[owner] then
                headerBg = playerBg[owner]
                headerFg = colors.white
            end

            frameRect(x, top, colW, availH, colors.gray, colors.black)
            fillRect(x + 1, top + 1, colW - 2, 1, headerBg)
            centerText(x + 1, top + 1, colW - 2, tostring(col), headerFg, headerBg)

            local trackTop = top + 3
            local trackBottom = bottom

            -- draw empty track cells
            for step = 1, len do
                local y = trackBottom - (step - 1)
                if y >= trackTop and y <= trackBottom then
                    fillRect(x + 1, y, colW - 2, 1, colors.lightGray, colors.black, " ")
                end
            end

            -- gather occupants per step
            local stepOccupants = {}
            for p = 1, numPlayers do
                local step = board[col].positions[p]
                if step and step > 0 then
                    stepOccupants[step] = stepOccupants[step] or {}
                    table.insert(stepOccupants[step], p)
                end
            end

            local function drawChip(step, fg, bg, ch)
                if not step or step <= 0 then return end
                local y = trackBottom - (step - 1)
                if y < trackTop or y > trackBottom then return end
                local mx = x + math.floor(colW / 2)
                writeAt(mx, y, ch or " ", fg, bg)
            end

            -- base markers
            for step, players in pairs(stepOccupants) do
                if #players > 1 then
                    drawChip(step, colors.black, flashPlayerColor(players), " ")
                else
                    local p = players[1]
                    drawChip(step, colors.black, playerBg[p] or colors.white, " ")
                end
            end

            -- temp marker (draw last so it pops)
            if showTemp then
                local t = tempMarkers[col]
                if t and t > 0 then
                    local tBg = (currentPlayer == 1) and colors.cyan or (currentPlayer == 2 and colors.orange or colors.lime)
                    drawChip(t, colors.black, tBg, " ")
                end
            end
        end

        -- (Pick options are rendered in the bottom 3-button bar during CHOOSE)
    end

    while true do
        tempMarkers = {}
        runnersUsed = 0
        local turnOver = false

        while not turnOver do
            audio.playShuffle()
            local dice = rollDice()
            local options = getPairings(dice)

            local function canAdvanceN(col)
                if board[col].owner then return false end
                if runnersUsed >= MAX_RUNNERS and not tempMarkers[col] then return false end
                local current = tempMarkers[col] or board[col].positions[currentPlayer]
                if current >= COL_LENGTHS[col] then return false end
                return true
            end

            local function isValidOptionN(opt)
                return canAdvanceN(opt[1]) or canAdvanceN(opt[2])
            end

            local canMove = false
            for _, opt in ipairs(options) do
                if isValidOptionN(opt) then canMove = true break end
            end

            if not canMove then
                local w2, h2 = term.getSize()
                drawBoardN(true, dice, nil, nil, "BUST")
                fillRect(1, h2 - 2, w2, 1, colors.black)
                writeAt(2, h2 - 2, "BUST! No valid moves.", colors.red, colors.black)
                audio.playLose()
                sleep(2)
                turnOver = true
            else
                local chosen = nil
                while not chosen do
                    drawBoardN(true, dice, nil, nil, "CHOOSE")

                    local function choiceLabel(i)
                        local opt = options[i]
                        if not opt then return tostring(i) .. ":--" end
                        local valid = isValidOptionN(opt)
                        if not valid then
                            return tostring(i) .. ":X"
                        end
                        return tostring(i) .. ":" .. tostring(opt[1]) .. "&" .. tostring(opt[2])
                    end

                    drawButtonBar(choiceLabel(1), choiceLabel(2), choiceLabel(3))

                    local key = waitKey(1.0)
                    if key == "RESIZE" then
                        -- loop will redraw
                        goto continue_choose
                    end
                    if key == "TICK" then
                        goto continue_choose
                    end
                    if key == "EXIT" then
                        return true
                    end

                    local selIdx = 0
                    if key == "LEFT" then selIdx = 1
                    elseif key == "CENTER" then selIdx = 2
                    elseif key == "RIGHT" then selIdx = 3 end

                    if selIdx > 0 and selIdx <= #options and isValidOptionN(options[selIdx]) then
                        chosen = options[selIdx]
                    end

                    ::continue_choose::
                end

                local function advance(col)
                    if not canAdvanceN(col) then return end
                    if not tempMarkers[col] then
                        runnersUsed = runnersUsed + 1
                        local start = board[col].positions[currentPlayer]
                        tempMarkers[col] = start + 1
                    else
                        tempMarkers[col] = tempMarkers[col] + 1
                    end
                end

                advance(chosen[1])
                advance(chosen[2])
                audio.playChip()

                local actionChosen = false
                while not actionChosen do
                    drawBoardN(true, dice, nil, nil, "ACTION")
                    drawActionMenu()

                    local key = waitKey(1.0)
                    if key == "RESIZE" then
                        goto continue_action
                    end
                    if key == "TICK" then
                        goto continue_action
                    end
                    if key == "EXIT" then
                        return true
                    end

                    if key == "LEFT" then
                        actionChosen = true
                    elseif key == "CENTER" then
                        for col, step in pairs(tempMarkers) do
                            board[col].positions[currentPlayer] = step
                            if step >= COL_LENGTHS[col] then
                                board[col].owner = currentPlayer
                                audio.playWin()
                            end
                        end
                        turnOver = true
                        actionChosen = true
                        audio.playConfirm()
                    elseif key == "RIGHT" then
                        -- View Board: no-op (redraw loop)
                    end

                    ::continue_action::
                end
            end
        end

        local owned = 0
        for col = 2, 12 do
            if board[col].owner == currentPlayer then owned = owned + 1 end
        end

        if owned >= 3 then
            local w2, h2 = term.getSize()
            term.setBackgroundColor(colors.black)
            term.clear()
            drawTitleBar("CAN'T STOP", "WIN")
            frameRect(math.floor(w2 / 2) - 14, math.floor(h2 / 2) - 2, 29, 5, colors.gray, colors.black)
            centerText(math.floor(w2 / 2) - 14, math.floor(h2 / 2) - 1, 29, "PLAYER " .. tostring(currentPlayer), colors.lime, colors.black)
            centerText(math.floor(w2 / 2) - 14, math.floor(h2 / 2) + 1, 29, "WINS!", colors.lime, colors.black)
            audio.playWin()
            sleep(2)
            return false
        end

        currentPlayer = (currentPlayer % numPlayers) + 1
    end
end

local function main()
    -- Free play (no credits / no casino hooks)
    while true do
        local exitRequested = runOneGame()
        if not DEDICATED then
            returnToMenu()
            return
        end
        -- Dedicated spawn machine: always restart instead of showing casino UI.
        if exitRequested then
            sleep(0.1)
        end
    end
end

main()

]=])

writeFile('cashier.lua', [[
-- cashier.lua
-- Arcade Cashier System
-- Handles Credit Cards (Floppy Disks) and Currency Exchange

local input = require("input")
local credits = require("credits")
local audio = require("audio")

-- === CONFIGURATION ===
local RATES_INPUT = {
    ["minecraft:diamond"] = 1,
    ["minecraft:obsidian"] = 4,
    ["minecraft:ender_eye"] = 16
}

local RATES_OUTPUT = {
    ["minecraft:diamond"] = 1,
    ["minecraft:ender_pearl"] = 16
}

local SCREENSAVER_TIMEOUT = 10 -- Seconds of inactivity before screensaver
local SCREENSAVER_DIR = "screensavers"

-- === PERIPHERALS ===
local drive = peripheral.find("drive")
local bridge = nil -- Deprecated: Replaced by Bank Chest
local monitors = { peripheral.find("monitor") }

-- Find all connected inventories
local function findAllInventories()
    local invs = {}
    for _, name in ipairs(peripheral.getNames()) do
        -- Wrap the peripheral
        local p = peripheral.wrap(name)
        
        -- Check if it's an inventory (has .list and .size)
        -- Also explicitly exclude things we know aren't "storage" chests for our purpose
        -- (like disk drives which technically have inventory space sometimes, or strict exclusions)
        local type = peripheral.getType(p)
        
        -- Exclude common non-chest peripherals
        if type ~= "drive" and type ~= "monitor" and type ~= "speaker" and type ~= "modem" and type ~= "computer" then
            -- Verify it has inventory methods
            if p.list and p.size and p.pushItems and p.pullItems then
                table.insert(invs, p)
            end
        end
    end
    return invs
end

local allInventories = findAllInventories()

local mon = nil
if #monitors > 0 then
    mon = monitors[1]
    mon.setTextScale(1)
    if mon.isColor() then
        term.redirect(mon)
    end
end

local w, h = term.getSize()

-- === STATE MANAGEMENT ===
local lastActivity = os.clock()
local chestConfig = nil -- Will hold { customer = "name", bank = "name" }

local function resetActivity()
    lastActivity = os.clock()
end

local function clear()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.white)
    term.clear()
    term.setCursorPos(1, 1)
end

local function centerText(y, text, color)
    term.setCursorPos(1, y)
    term.clearLine()
    local x = math.floor((w - #text) / 2) + 1
    term.setCursorPos(x, y)
    if color then term.setTextColor(color) end
    term.write(text)
end

-- === CONFIGURATION WIZARD ===
local function configureChests()
    -- Priority 1: Check for explicit "bank" and "drawer" named peripherals
    local hasBank = peripheral.isPresent("bank")
    local hasDrawer = peripheral.isPresent("drawer")

    if hasBank and hasDrawer then
        -- Verify they are inventories (optional but good practice)
        chestConfig = { bank = "bank", customer = "drawer" }
        
        -- Save config
        local f = fs.open(".chest_config", "w")
        f.write(textutils.serialize(chestConfig))
        f.close()
        return
    end

    -- Priority 2: Wizard (Mandatory if not named bank/drawer)
    while true do
        allInventories = findAllInventories()
        
        if #allInventories < 2 then
            clear()
            centerText(h/2-1, "SETUP ERROR", colors.red)
            centerText(h/2+1, "Need 2 Chests Connected", colors.white)
            centerText(h/2+2, "Found: " .. #allInventories, colors.gray)
            sleep(2)
        else
            clear()
            centerText(2, "PAYMENT CONFIG", colors.cyan)
            
            centerText(4, "Hardware Names:", colors.gray)
            centerText(5, "'bank' & 'drawer' not found.", colors.red)
            
            centerText(7, "Step 1: EMPTY All Chests", colors.yellow)
            centerText(9, "Step 2: Put 1 DIAMOND in", colors.yellow)
            centerText(10, "the DRAWER (Input) Chest", colors.yellow) 
            
            centerText(h-2, "Scanning...", colors.gray)
            
            -- Scan loop
            local customerChestName = nil
            local bankChestName = nil
            
            for _, inv in ipairs(allInventories) do
                local items = inv.list()
                for slot, item in pairs(items) do
                    if item.name == "minecraft:diamond" then
                        customerChestName = peripheral.getName(inv)
                        break
                    end
                end
                if customerChestName then break end
            end
            
            if customerChestName then
                -- Automatically assign the first OTHER chest as Bank
                for _, inv in ipairs(allInventories) do
                    local name = peripheral.getName(inv)
                    if name ~= customerChestName then
                        bankChestName = name
                        break
                    end
                end
                
                if bankChestName then
                   clear()
                   centerText(h/2, "CONFIG SUCCESS!", colors.lime)
                   centerText(h/2+2, "Drawer: " .. customerChestName, colors.gray)
                   centerText(h/2+3, "Bank: " .. bankChestName, colors.gray)
                   
                   chestConfig = { customer = customerChestName, bank = bankChestName }
                   
                   local f = fs.open(".chest_config", "w")
                   f.write(textutils.serialize(chestConfig))
                   f.close()
                   
                   -- Attempt to label the peripherals appropriately if possible
                   -- (This fulfills the 'name them appropriately' request if supported)
                   pcall(function() peripheral.call(customerChestName, "setLabel", "drawer") end)
                   pcall(function() peripheral.call(bankChestName, "setLabel", "bank") end)
                   
                   centerText(h-2, "Please Remove Diamond", colors.yellow)
                   sleep(3)
                   
                   -- Wait for diamond removal
                   while true do
                        local hasItem = false
                        local inv = peripheral.wrap(customerChestName)
                        for k,v in pairs(inv.list()) do hasItem = true end
                        if not hasItem then break end
                        sleep(0.5)
                   end
                   return
                end
            end
            sleep(1)
        end
    end
end

-- === ANIMATIONS ===

local function animateCountUp(startVal, endVal, y, labelColor, valColor)
    local steps = 10
    local delay = 0.05
    local diff = endVal - startVal
    
    if diff == 0 then return end
    
    for i = 1, steps do
        local current = math.floor(startVal + (diff * (i/steps)))
        centerText(y, "CREDITS: " .. current, valColor or colors.yellow)
        sleep(delay)
    end
end

local function animateScanning(y)
    local frames = {
        "ScAnNiNg...",
        "sCaNnInG...",
        "ScAnNiNg...",
        "sCaNnInG..."
    }
    for _, f in ipairs(frames) do
        centerText(y, f, colors.yellow)
        sleep(0.1)
    end
end

local function animateDispense(y)
    centerText(y, "Dispensing...", colors.yellow)
    audio.playCoinDispense()
    for i=1,3 do
        centerText(y, "Dispensing" .. string.rep(".", i), colors.yellow)
        sleep(0.15)
    end
end

-- === SCREENSAVER ===
local function runScreensaver()
    if not fs.exists(SCREENSAVER_DIR) or not fs.isDir(SCREENSAVER_DIR) then
        return
    end
    
    local files = fs.list(SCREENSAVER_DIR)
    if #files == 0 then return end
    
    local randomFile = files[math.random(1, #files)]
    local fullPath = fs.combine(SCREENSAVER_DIR, randomFile)
    
    local function screensaverRoutine()
        shell.run(fullPath)
    end
    
    local function inputWatcher()
        local ev, p1 = os.pullEvent()
        while true do
            if ev == "key" or ev == "mouse_click" or ev == "monitor_touch" or ev == "disk" then
                return true
            end
            ev, p1 = os.pullEvent()
        end
    end
    
    parallel.waitForAny(screensaverRoutine, inputWatcher)
    
    resetActivity()
    clear()
end

-- === LOGIC ===

local function scanIOChest()
    if not chestConfig then return 0, {} end
    local cust = peripheral.wrap(chestConfig.customer)
    if not cust then return 0, {} end
    
    local total = 0
    local items = {}
    
    for slot, item in pairs(cust.list()) do
        local rate = RATES_INPUT[item.name]
        if rate then
            local val = rate * item.count
            total = total + val
            table.insert(items, {slot=slot, name=item.name, count=item.count, value=val})
        else
             -- Also track invalid items to move them to bank (garbage collection)
             table.insert(items, {slot=slot, name=item.name, count=item.count, value=0, garbage=true})
        end
    end
    return total, items
end

local function safeTransfer(fromObj, fromName, toObj, toName, fromSlot, count)
    local moved = 0

    -- Attempt 1: Push from Source
    local pushOk, pushRes = pcall(function()
        return fromObj.pushItems(toName, fromSlot, count)
    end)

    if pushOk and type(pushRes) == "number" and pushRes > 0 then
        moved = pushRes
        if moved >= count then
            return moved
        end
    end

    -- Attempt 2: Pull remaining from Destination
    local remaining = count - moved
    local pullOk, pullRes = pcall(function()
        return toObj.pullItems(fromName, fromSlot, remaining)
    end)

    if pullOk and type(pullRes) == "number" and pullRes > 0 then
        moved = moved + pullRes
    end

    if moved > 0 then
        return moved
    end

    -- Return error info (includes successful 0-move results for debugging)
    local err = "Transfer Failed."
    err = err .. " Push: " .. tostring(pushRes)
    err = err .. " Pull: " .. tostring(pullRes)
    if not pushOk then err = err .. " (push error)" end
    if not pullOk then err = err .. " (pull error)" end
    return 0, err
end

local function depositItems(items)
    if not chestConfig then return false, "No Config" end
    local cust = peripheral.wrap(chestConfig.customer)
    local bank = peripheral.wrap(chestConfig.bank)
    
    if not cust or not bank then return false, "Chest Missing" end
    
    local totalCredits = 0
    local lastError = nil
    
    for _, item in ipairs(items) do
        -- Move item from Customer to Bank using safe transfer
        local moved, err = safeTransfer(cust, chestConfig.customer, bank, chestConfig.bank, item.slot, item.count)
        
        if moved and moved > 0 and not item.garbage then
             local rate = RATES_INPUT[item.name]
             if rate then
                totalCredits = totalCredits + (moved * rate)
             end
        elseif err then
            lastError = err
        end
    end
    
    return true, totalCredits, lastError
end

local function withdrawItem(itemName, count)
    if not chestConfig then return 0 end
    local cust = peripheral.wrap(chestConfig.customer)
    local bank = peripheral.wrap(chestConfig.bank)
    if not cust or not bank then return 0 end
    
    -- Find item in Bank
    local transferred = 0
    local hasAny = false
    local lastError = nil
    for slot, item in pairs(bank.list()) do
        if item.name == itemName then
            hasAny = true
            local needed = count - transferred
            
            -- Bank -> Customer
            local pushed, err = safeTransfer(bank, chestConfig.bank, cust, chestConfig.customer, slot, needed)
            if err then lastError = err end
            
            transferred = transferred + pushed
            if transferred >= count then break end
        end
    end

    if transferred > 0 then
        return transferred, "ok"
    end
    if not hasAny then
        return 0, "out_of_stock"
    end
    return 0, "transfer_failed", lastError
end

-- === MENUS ===

local function menuDeposit(cardPath)
    -- Initial scan
    local val, items = scanIOChest()
    
    while true do
        clear()
        centerText(2, "DEPOSIT ITEMS", colors.yellow)
        centerText(4, "Place items in chest", colors.white)
        centerText(5, "Diamonds (1), Obsidian (4)", colors.gray)
        centerText(6, "Eyes of Ender (16)", colors.gray)
        
        -- Sum only valid values for display
        local displayVal = 0
        for _, it in ipairs(items) do if not it.garbage then displayVal = displayVal + it.value end end
        
        if displayVal > 0 then
            centerText(8, "Detected: " .. displayVal .. " Credits", colors.lime)
        else
            centerText(8, "Scanning Chest...", colors.gray)
        end
        
        centerText(h-2, "[BTN 1] Confirm & Deposit", colors.lime)
        centerText(h-1, "[BTN 3] Back", colors.red)
        
        local timer = os.startTimer(0.5)
        local event, p1 = os.pullEvent()
        
        if event == "timer" then
             _, items = scanIOChest()
        else
            resetActivity()
            local btn = input.getButton(event, p1)
            
            if btn == "LEFT" then -- Button 1
                audio.playClick()
                -- Filter items list to ensure we actually have something to move (even garbage)
                if #items > 0 then
                    animateScanning(h-4)
                    local success, result, err = depositItems(items)
                    
                    if success then
                        if type(result) == "number" and result > 0 then
                             audio.playCashRegister()
                             credits.add(result, cardPath)
                             
                             clear()
                             centerText(h/2, "DEPOSIT SUCCESS", colors.lime)
                             centerText(h/2+1, "+" .. result .. " CREDITS", colors.yellow)
                             sleep(1.5)
                             return
                        elseif result == 0 then
                            -- Only garbage moved or transfer failed
                             clear()
                             if err and (string.find(err, "Target") or string.find(err, "target")) then
                                 centerText(h/2-2, "NETWORK ERROR", colors.red)
                                 centerText(h/2, "Chests cannot see each other", colors.white)
                                 centerText(h/2+1, "Connect WIRED MODEMS to BOTH", colors.yellow)
                                 centerText(h/2+2, "Chests/Barrels", colors.yellow)
                                 sleep(6)
                             else
                                 centerText(h/2, "Invalid Items Stored", colors.red)
                                 if err then
                                    centerText(h/2+2, string.sub(err, 1, 38), colors.gray) 
                                 end
                                 sleep(3.5)
                             end
                        else
                             audio.playError()
                             centerText(h-4, "Error: 0 Deposited", colors.red)
                             sleep(1)
                        end
                    else
                         audio.playError()
                         centerText(h-4, "Error: " .. tostring(result), colors.red)
                         sleep(2)
                    end
                    _, items = scanIOChest()
                else
                    audio.playError()
                    centerText(h-4, "Chest Empty", colors.red)
                    sleep(0.5)
                end
                
            elseif btn == "RIGHT" then -- Button 3
                audio.playClick()
                return
            end
        end
    end
end

local function menuWithdraw(cardPath)
    local currentSelection = 1 
    local options = {
        { name = "Diamond", id="minecraft:diamond", cost = 1, rate = 1, label="1 Credit -> 1 Diamond" },
        { name = "Ender Pearl", id="minecraft:ender_pearl", cost = 16, rate = 16, label="16 Credits -> 1 Pearl" }
    }
    
    while true do
        clear()
        local currentCreds = credits.get(cardPath)
        centerText(2, "CASH OUT", colors.yellow)
        centerText(3, "Credits: " .. currentCreds, colors.white)
        
        for i, opt in ipairs(options) do
            local y = 5 + (i * 3)
            local prefix = (i == currentSelection) and "> " or "  "
            local color = (i == currentSelection) and colors.lime or colors.gray
            centerText(y, prefix .. opt.name, color)
            centerText(y+1, "(" .. opt.label .. ")", colors.gray)
        end
        
        centerText(h-2, "[1] Select   [2] Confirm", colors.cyan)
        centerText(h-1, "[3] Back", colors.red)
        
        local event, p1 = os.pullEvent()
        resetActivity()
        local btn = input.getButton(event, p1)
        
        if btn == "LEFT" then -- Cycle Selection
            audio.playClick()
            currentSelection = currentSelection + 1
            if currentSelection > #options then currentSelection = 1 end
            
        elseif btn == "CENTER" then -- Confirm
            audio.playConfirm()
            local opt = options[currentSelection]
            
            if currentCreds >= opt.rate then
                clear()
                centerText(h/2-2, "Dispensing " .. opt.name, colors.white)
                
                local moved, status, err = withdrawItem(opt.id, 1)
                
                if moved and moved >= 1 then
                    animateDispense(h/2)
                    credits.remove(opt.rate, cardPath)
                    
                    clear()
                    centerText(h/2, "Please Take Item", colors.lime)
                    sleep(1)
                else
                    audio.playError()
                    if status == "out_of_stock" then
                        centerText(h/2+2, "Bank Empty!", colors.red)
                        sleep(1.5)
                    elseif err and (string.find(err, "Target") or string.find(err, "target")) then
                        centerText(h/2-2, "NETWORK ERROR", colors.red)
                        centerText(h/2, "Chests cannot see each other", colors.white)
                        centerText(h/2+1, "Connect WIRED MODEMS to BOTH", colors.yellow)
                        centerText(h/2+2, "Chests/Barrels", colors.yellow)
                        sleep(6)
                    else
                        centerText(h/2-1, "TRANSFER ERROR", colors.red)
                        if err then
                            centerText(h/2+1, string.sub(tostring(err), 1, 38), colors.gray)
                        end
                        sleep(3)
                    end
                end
            else
                audio.playError()
                centerText(h-3, "Insufficient Credits!", colors.red)
                sleep(1)
            end
            
        elseif btn == "RIGHT" then -- Back
            audio.playClick()
            return
        end
    end
end

local function menuMain(cardPath)
    local lastCredits = credits.get(cardPath)

    while true do
        if not drive or not drive.isDiskPresent() then return end 
        
        local name = credits.getName(cardPath) or "Player"
        local bal = credits.get(cardPath)
        
        clear()
        centerText(2, "WELCOME, " .. string.upper(name), colors.cyan)
        
        -- Credits Display
        centerText(4, "CREDITS: " .. bal, colors.yellow)
        
        centerText(7, "[1] DEPOSIT Items", colors.white)
        centerText(9, "[2] CASH OUT", colors.white)
        centerText(11, "[3] EJECT CARD", colors.red)
        
        -- Fun check for items waiting
        local val, _ = scanIOChest()
        if val > 0 then
             centerText(h-1, "Items Detected! Use [1]", colors.lime)
        end
        
        local event, p1 = os.pullEvent()
        resetActivity()
        local btn = input.getButton(event, p1)
        
        if btn == "LEFT" then -- Deposit
            audio.playClick()
            menuDeposit(cardPath)
        elseif btn == "CENTER" then -- Cash Out
            audio.playClick()
            menuWithdraw(cardPath)
        elseif btn == "RIGHT" then -- Eject
            audio.playClick()
            if drive then drive.ejectDisk() end
            return
        end
    end
end

local function promptNewCard(cardPath)
    -- If card has no data/corrupt, init it
    if not credits.getName(cardPath) then
        credits.set(0, cardPath) 
    end
    menuMain(cardPath)
end



local function checkHardware()
    local errors = {}
    
    -- 1. Inventory Check
    allInventories = findAllInventories()
    if #allInventories < 2 then
        table.insert(errors, "Need 2 Connected Chests")
        table.insert(errors, "Found: " .. #allInventories)
    end
    
    -- 2. Speaker Check
    if not peripheral.find("speaker") then
        table.insert(errors, "Missing Speaker")
    end
    
    -- 3. Drive Check
    if not drive then
        table.insert(errors, "Missing Disk Drive")
    end
    
    -- 4. Redstone Config Check
    if not fs.exists(".button_config") then
        table.insert(errors, "Config Missing! Run config.lua")
    else
        local f = fs.open(".button_config", "r")
        local success, conf = pcall(function() return textutils.unserialize(f.readAll()) end)
        f.close()
        
        if not success or not conf or not conf.LEFT or not conf.CENTER or not conf.RIGHT then
            table.insert(errors, "Invalid Button Config")
        else
            local rsCount = 0
            if conf.LEFT.type == "redstone" then rsCount = rsCount + 1 end
            if conf.CENTER.type == "redstone" then rsCount = rsCount + 1 end
            if conf.RIGHT.type == "redstone" then rsCount = rsCount + 1 end
            
            if rsCount < 3 then
                table.insert(errors, "Need 3 Redstone Buttons")
            end
        end
    end
    
    if #errors > 0 then
        -- Force display to available output using standard print for safety
        term.setBackgroundColor(colors.black)
        term.clear()
        term.setCursorPos(1, 1)
        
        term.setTextColor(colors.red)
        print("HARDWARE CHECK FAILED")
        print("---------------------")
        
        term.setTextColor(colors.white)
        for i, err in ipairs(errors) do
            print("- " .. err)
        end
        
        print("")
        term.setTextColor(colors.yellow)
        print("Press any key to reboot...")
        os.pullEvent("key")
        os.reboot()
    end
    
    -- Config Wizard if needed
    configureChests()
    
    -- Success
    clear()
    centerText(h/2, "Hardware Verified", colors.lime)
    sleep(0.5)
end

-- === MAIN LOOP ===

local function main()
    checkHardware()

    while true do
        if not drive then
            clear()
            centerText(h/2, "Error: No Drive Found", colors.red)
            sleep(5)
            drive = peripheral.find("drive")
        else
            if drive.isDiskPresent() then
                resetActivity()
                local mount = drive.getMountPath()
                if mount then
                    promptNewCard(mount)
                else
                     sleep(0.5)
                end
            else
                -- IDLE STATE
                clear()
                centerText(h/2 - 1, "INSERT PLAYER CARD", colors.lime)
                
                -- Idle scan for customers putting things in input
                local val, _ = scanIOChest()
                if val > 0 then
                    resetActivity() 
                    centerText(h/2 + 1, "Items Detected!", colors.yellow)
                    centerText(h/2 + 2, "Insert Card to Deposit", colors.white)
                end
                
                if os.clock() - lastActivity > SCREENSAVER_TIMEOUT then
                    runScreensaver()
                end
                
                local timer = os.startTimer(1)
                local event, p1 = os.pullEvent()
                
                if event == "disk" then
                    resetActivity()
                elseif event == "timer" then
                    -- loop
                else
                    -- Input reset
                    local btn = input.getButton(event, p1)
                    if btn or event == "monitor_touch" or event == "mouse_click" or event == "char" or event == "key" then
                        resetActivity()
                    end
                end
            end
        end
    end
end

main()


]])

writeFile('config.lua', [[
-- config.lua
-- Button Configuration Wizard

local function clear()
    term.clear()
    term.setCursorPos(1, 1)
end

local function saveConfig(config)
    local file = fs.open(".button_config", "w")
    file.write(textutils.serialize(config))
    file.close()
end

local function waitForInput(buttonName)
    clear()
    print("BUTTON SETUP")
    print("============")
    print("")
    print("Please press the " .. buttonName .. " button.")
    print("(Press a Key or activate Redstone)")
    
    while true do
        local event, p1 = os.pullEvent()
        
        if event == "key" then
            -- p1 is key code
            return { type = "key", value = p1 }
            
        elseif event == "redstone" then
            -- Check all sides for active input
            for _, side in ipairs(rs.getSides()) do
                if rs.getInput(side) then
                    -- Wait for signal to turn off to avoid double detection?
                    -- For now, just accept it.
                    return { type = "redstone", value = side }
                end
            end
        end
    end
end

-- Main Wizard
local config = {}

-- 1. Left Button
config.LEFT = waitForInput("LEFT")
print("Captured!")
sleep(0.5)

-- 2. Center Button
config.CENTER = waitForInput("CENTER")
print("Captured!")
sleep(0.5)

-- 3. Right Button
config.RIGHT = waitForInput("RIGHT")
print("Captured!")
sleep(0.5)

-- Save
saveConfig(config)

clear()
print("Configuration Saved!")
print("Left: " .. config.LEFT.type .. " " .. config.LEFT.value)
print("Center: " .. config.CENTER.type .. " " .. config.CENTER.value)
print("Right: " .. config.RIGHT.type .. " " .. config.RIGHT.value)
print("")
print("Continuing startup...")
sleep(2)

]])

writeFile('credits.lua', [[
local DEFAULT_CREDITS = 0 
local DEFAULT_NAME = "Guest"

local credits = {}

local function getFilePath(mountPath)
    return (mountPath or "disk") .. "/credits.json"
end

local function readData(mountPath)
    local path = getFilePath(mountPath)
    if not fs.exists(path) then
        return nil
    end
    
    local f = fs.open(path, "r")
    if not f then return nil end
    local content = f.readAll()
    f.close()
    
    local data = textutils.unserializeJSON(content)
    return data
end

local function writeData(mountPath, data)
    local path = getFilePath(mountPath)
    -- Only write if the directory exists (disk is present)
    local dir = fs.getDir(path)
    if not fs.exists(dir) then
        return false 
    end

    local f = fs.open(path, "w")
    if f then
        f.write(textutils.serializeJSON(data))
        f.close()
        return true
    end
    return false
end

-- Find all connected disks with credits info
function credits.findCards()
    local cards = {}
    for _, side in ipairs(peripheral.getNames()) do
        if peripheral.getType(side) == "drive" then
            local path = disk.getMountPath(side)
            if path then
                local data = readData(path)
                if data then
                    table.insert(cards, {
                        path = path, 
                        side = side,
                        name = data.name or DEFAULT_NAME,
                        credits = data.credits or DEFAULT_CREDITS
                    })
                end
            end
        end
    end
    return cards
end

function credits.get(mountPath)
    if _G.ARCADE_DEV_MODE then
        return math.huge
    end

    local data = readData(mountPath)
    if not data or not data.credits then
        return DEFAULT_CREDITS
    end
    
    return tonumber(data.credits) or DEFAULT_CREDITS
end

function credits.getName(mountPath)
    local data = readData(mountPath)
    if not data or not data.name then
        return nil
    end
    return data.name
end

function credits.set(amount, mountPath)
    if _G.ARCADE_DEV_MODE then
        return true 
    end

    local data = readData(mountPath) or { name = DEFAULT_NAME }
    data.credits = math.floor(amount)
    
    return writeData(mountPath, data)
end

function credits.add(amount, mountPath)
    local current = credits.get(mountPath)
    local newAmount = current + amount
    credits.set(newAmount, mountPath)
    return newAmount
end

function credits.remove(amount, mountPath)
    if _G.ARCADE_DEV_MODE then
        return true 
    end

    local current = credits.get(mountPath)
    if current >= amount then
        credits.set(current - amount, mountPath)
        return true
    else
        return false
    end
end

function credits.lock(mountPath)
    local data = readData(mountPath)
    if data then
        data.in_game = true
        writeData(mountPath, data)
    end
end

function credits.unlock(mountPath)
    local data = readData(mountPath)
    if data then
        data.in_game = false
        writeData(mountPath, data)
    end
end

return credits

]])

writeFile('dedicate.lua', [[
-- dedicate.lua
-- Simple installer for dedicated (kiosk) machines.
-- Writes .arcade_config + kiosk flag files, then reboots.

local function clear()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.white)
    term.clear()
    term.setCursorPos(1, 1)
end

local function writeFile(path, content)
    local f = fs.open(path, "w")
    if not f then return false end
    f.write(content)
    f.close()
    return true
end

local function deleteFile(path)
    if fs.exists(path) then
        fs.delete(path)
    end
end

local function isKioskEnabled()
    return fs.exists(".kiosk_mode")
end

local function currentCmd()
    if not fs.exists(".arcade_config") then return nil end
    local f = fs.open(".arcade_config", "r")
    if not f then return nil end
    local cmd = (f.readAll() or "")
    f.close()
    cmd = cmd:gsub("%s+", "")
    if cmd == "" then return nil end
    return cmd
end

local function pause()
    while true do
        local e, p1 = os.pullEvent()
        if e == "key" or e == "mouse_click" or e == "monitor_touch" then
            return
        end
    end
end

clear()
print("DEDICATED INSTALLER")
print("===================")
print("")
print("This will configure this computer to run")
print("only one game (kiosk mode).")
print("")
print("Current: " .. tostring(currentCmd() or "<none>"))
print("Kiosk:   " .. (isKioskEnabled() and "ON" or "OFF"))
print("")
print("1) Dedicated: Can't Stop (spawn)")
print("2) Disable kiosk (return to normal)")
print("")
print("Press 1 or 2...")

while true do
    local e, key = os.pullEvent("key")
    local name = keys.getName(key)

    if name == "one" or name == "numPad1" then
        -- Dedicated Can't Stop
        clear()
        print("Installing: Can't Stop kiosk...")
        writeFile(".arcade_config", "cant_stop")
        writeFile(".kiosk_mode", "1")
        writeFile(".kiosk_game", "cant_stop")
        print("Done. Rebooting...")
        sleep(1)
        os.reboot()

    elseif name == "two" or name == "numPad2" then
        -- Disable kiosk mode
        clear()
        print("Disabling kiosk mode...")
        deleteFile(".kiosk_mode")
        deleteFile(".kiosk_game")
        print("Done.")
        print("Tip: run setup.lua or edit .arcade_config")
        print("to choose a different default program.")
        print("")
        print("Rebooting...")
        sleep(1)
        os.reboot()
    end
end

]])

writeFile('exchange.lua', [[
local credits = require("credits")
local completion = require("cc.completion")

-- Configuration
local PRICES = {
    ["minecraft:diamond"] = 1,
    ["minecraft:obsidian"] = 4,
    ["minecraft:ender_eye"] = 16
}

local mon = peripheral.find("monitor")
local drive = peripheral.find("drive")
local chest = nil
local storage = nil

-- Attempt to find chests/inventories
local periphs = peripheral.getNames()
for _, name in ipairs(periphs) do
    if peripheral.getType(name) == "minecraft:chest" or peripheral.getType(name) == "minecraft:barrel" then
        if not chest then
            chest = peripheral.wrap(name)
        elseif not storage then
            storage = peripheral.wrap(name)
        end
    end
end

-- If only one chest found, assume we are a turtle or we void items? 
-- The user said "sucked in". 
-- If we are a command computer, maybe we can clearslot?
-- For now, if no storage, we will just count and NOT move (safety) unless we are a turtle.
local is_turtle = turtle ~= nil

local function getDriveSide()
    for _, name in ipairs(periphs) do
        if peripheral.getType(name) == "drive" then
            return name
        end
    end
    return nil
end

local driveSide = getDriveSide()

local interacting = false

local function showAttract()
    if not mon then return end
    mon.setTextScale(1)
    mon.setBackgroundColor(colors.black)
    
    local w, h = mon.getSize()
    local colors_list = {colors.red, colors.orange, colors.yellow, colors.lime, colors.blue, colors.purple}
    
    local i = 1
    while true do
        if not interacting then
            mon.setBackgroundColor(colors.black)
            mon.clear()
            mon.setCursorPos(1, h/2)
            mon.setTextColor(colors_list[i])
            mon.setTextScale(2)
            local msg = "TURN IN COINS!"
            -- Center roughly
            mon.setCursorPos(3, 2) 
            mon.write(msg)
            
            mon.setTextScale(1)
            mon.setCursorPos(1, h-2)
            mon.setTextColor(colors.white)
            mon.write("No Disk? Check Chest!")
            
            i = i + 1
            if i > #colors_list then i = 1 end
            sleep(0.5)
        else
            sleep(0.5)
        end
    end
end

local function drawStatus(msg, color)
    if not mon then return end
    mon.setBackgroundColor(colors.black)
    mon.clear()
    mon.setCursorPos(1, 1)
    mon.setTextColor(color or colors.white)
    mon.setTextScale(1)
    mon.write(msg)
end

local function launchFireworks()
    -- Only works if command computer or configured
    if commands then
       -- Summon random firework
       commands.exec("summon firework_rocket ~ ~2 ~ {LifeTime:15,FireworksItem:{id:firework_rocket,Count:1,tag:{Fireworks:{Flight:1,Explosions:[{Type:1,Flicker:1,Trail:1,Colors:[I;11743532],FadeColors:[I;11743532]}]}}}}")
    else
        -- Fallback sound or visualization could go here
    end
end

local function processItems(mountPath)
    if not chest then return end
    
    local total_credit_gain = 0
    
    -- Iterate all slots
    for slot, item in pairs(chest.list()) do
        if PRICES[item.name] then
            local value = PRICES[item.name]
            local count = item.count
            local gain = value * count
            
            -- Move logic
            local moved = false
            if storage then
                -- Push to storage
                local pushed = chest.pushItems(peripheral.getName(storage), slot)
                if pushed == count then moved = true end
            elseif is_turtle then
                -- Turtle suck (must be facing chest)
                -- This is tricky if we don't know orientation. 
                -- We'll assume standard computer behavior first.
            else
                 -- WE CANNOT DESTROY ITEMS SAFELY WITHOUT STORAGE
                 -- but maybe the user wants us to?
                 -- User said "sucked in". 
                 -- Let's try to push to ANY other inventory found that is not the drive.
                 for _, p in ipairs(peripheral.getNames()) do
                    if p ~= peripheral.getName(chest) and p ~= peripheral.getName(drive) and peripheral.getType(p) ~= "monitor" and peripheral.getType(p) ~= "modem" then
                        -- try push
                        local pushed = chest.pushItems(p, slot)
                        if pushed >= count then 
                            moved = true 
                            break 
                        end
                    end
                 end
            end
            
            if moved then
                total_credit_gain = total_credit_gain + gain
                -- print("Processed " .. item.name .. " x" .. count .. " = " .. gain)
            else
                -- Could not move items
                if mon then
                     local w, h = mon.getSize()
                     mon.setCursorPos(1, h-1)
                     mon.setTextColor(colors.red)
                     mon.write("ERR: CANNOT MOVE ITEM")
                     sleep(1)
                     mon.setCursorPos(1, h-1)
                     mon.clearLine()
                end
            end
        end
    end
    
    if total_credit_gain > 0 then
        credits.add(total_credit_gain, mountPath)
        return total_credit_gain
    end
    return 0
end

local function mainLoop()
    local hadDisk = false
    
    while true do
        local hasDisk = disk.isPresent(driveSide)
        local mountPath = disk.getMountPath(driveSide)
        
        if hasDisk and mountPath then
            interacting = true
            if not hadDisk then
                if mon then
                    mon.setBackgroundColor(colors.black) -- Clear animation
                    mon.clear()
                end
                hadDisk = true
            end
            
            -- User logic
            local current = credits.get(mountPath)
            local name = credits.getName(mountPath) or "Guest"
            
            if mon then
                mon.setCursorPos(1,1)
                mon.setTextColor(colors.lime)
                mon.write("Welcome, " .. name)
                mon.setCursorPos(1,2)
                mon.write("Credits: " .. current)
                mon.setCursorPos(1,4)
                mon.setTextColor(colors.white)
                mon.write("Place items in chest...")
            end
            
            local gained = processItems(mountPath)
            if gained > 0 then
                if mon then
                    mon.setCursorPos(1,6)
                    mon.setTextColor(colors.yellow)
                    mon.write("Added: " .. gained .. " credits!")
                    sleep(1)
                    mon.setCursorPos(1,6) 
                    mon.clearLine()
                end
            end
            
        else
            -- No disk
            interacting = false
            if hadDisk then hadDisk = false end
            
            -- Check if someone is interacting (e.g. items in chest but no disk)
            local chestHasItems = false
            if chest then
                local list = chest.list()
                if list then
                    for slot, item in pairs(list) do
                        if PRICES[item.name] then
                            chestHasItems = true
                            break
                        end
                    end
                end
            end

            if chestHasItems then
                -- "Throws fireworks and encourages them"
                launchFireworks()
                -- We rely on parallel animation to show "TURN IN COINS" / "INSERT DISK"
                sleep(2) -- Don't spam fireworks
            end
        end
        
        sleep(0.5)
    end
end

-- Run
if not mon then
    print("Error: No monitor found.")
    return
end

parallel.waitForAny(showAttract, mainLoop)

]])

writeFile('input.lua', [[
-- input.lua
-- Input handling for Arcade OS

local config = {
    LEFT = { type = "key", value = keys.left },
    CENTER = { type = "key", value = keys.up },
    RIGHT = { type = "key", value = keys.right }
}

-- Load config if exists
if fs.exists(".button_config") then
    local file = fs.open(".button_config", "r")
    if file then
        local data = file.readAll()
        file.close()
        local loaded = textutils.unserialize(data)
        if loaded then
            config = loaded
        end
    end
end

-- Also support default keys for keyboard fallback
local DEFAULT_KEYS = {
    LEFT = { keys.left, keys.a, keys.q },
    CENTER = { keys.up, keys.w, keys.space, keys.enter },
    RIGHT = { keys.right, keys.d, keys.e }
}

local function isKey(key, set)
    for _, k in ipairs(set) do
        if key == k then return true end
    end
    return false
end

-- Track last-known redstone states so we can detect which button was pressed
-- on the rising edge (helps when multiple inputs are momentarily high).
local lastRedstone = {
    LEFT = false,
    CENTER = false,
    RIGHT = false
}

local function getButton(event, p1)
    if event == "key" then
        -- Check configured keys
        if config.LEFT.type == "key" and p1 == config.LEFT.value then return "LEFT" end
        if config.CENTER.type == "key" and p1 == config.CENTER.value then return "CENTER" end
        if config.RIGHT.type == "key" and p1 == config.RIGHT.value then return "RIGHT" end
        
        -- Check default keys (fallback/keyboard support)
        if isKey(p1, DEFAULT_KEYS.LEFT) then return "LEFT" end
        if isKey(p1, DEFAULT_KEYS.CENTER) then return "CENTER" end
        if isKey(p1, DEFAULT_KEYS.RIGHT) then return "RIGHT" end

    elseif event == "char" then
        -- Numeric keyboard fallback matching on-screen prompts
        local c = tostring(p1 or "")
        if c == "1" then return "LEFT" end
        if c == "2" then return "CENTER" end
        if c == "3" then return "RIGHT" end
        
    elseif event == "redstone" then
        -- Prefer configured redstone using rising-edge detection.
        local states = {
            LEFT = (config.LEFT.type == "redstone") and redstone.getInput(config.LEFT.value) or false,
            CENTER = (config.CENTER.type == "redstone") and redstone.getInput(config.CENTER.value) or false,
            RIGHT = (config.RIGHT.type == "redstone") and redstone.getInput(config.RIGHT.value) or false
        }

        local candidates = {}
        for name, now in pairs(states) do
            if now and not lastRedstone[name] then
                table.insert(candidates, name)
            end
        end

        -- Update memory before returning
        lastRedstone.LEFT = states.LEFT
        lastRedstone.CENTER = states.CENTER
        lastRedstone.RIGHT = states.RIGHT

        if #candidates == 1 then
            return candidates[1]
        end
        if #candidates > 1 then
            -- Ambiguous press (multiple lines rose at once). Ignore.
            return nil
        end
        
        -- Default redstone fallback (Legacy support)
        -- Only check if NOT configured as redstone to avoid double counting if config matches default
        if config.LEFT.type ~= "redstone" and redstone.getInput("left") then return "LEFT" end
        if config.RIGHT.type ~= "redstone" and redstone.getInput("right") then return "RIGHT" end
        if config.CENTER.type ~= "redstone" and (redstone.getInput("top") or redstone.getInput("front")) then return "CENTER" end
    end
    return nil
end

return {
    getButton = getButton
}

]])

writeFile('kiosk.lua', [[
-- kiosk.lua
-- Kiosk launcher: runs the configured game forever.
-- Intended for spawn / public machines (e.g., dedicated Can't Stop).

local function readArcadeConfig()
    if not fs.exists(".arcade_config") then return nil end
    local f = fs.open(".arcade_config", "r")
    if not f then return nil end
    local cmd = (f.readAll() or "")
    f.close()
    cmd = cmd:gsub("%s+", "")
    if cmd == "" then return nil end
    return cmd
end

local function clear()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.white)
    term.clear()
    term.setCursorPos(1, 1)
end

while true do
    _G.ARCADE_KIOSK = true
    local cmd = readArcadeConfig() or "cant_stop"

    -- Run the game; if it errors or is terminated, just restart.
    local ok, err = pcall(function()
        if fs.exists(cmd .. ".lua") then
            shell.run(cmd)
        else
            clear()
            print("KIOSK ERROR")
            print("Missing program: " .. cmd .. ".lua")
            sleep(2)
        end
    end)

    -- Swallow all errors (including Ctrl+T "Terminated").
    if not ok then
        clear()
        term.setTextColor(colors.red)
        print("Restarting kiosk...")
        term.setTextColor(colors.gray)
        print(tostring(err))
        sleep(0.6)
    else
        sleep(0.1)
    end
end

]])

writeFile('menu.lua', [[
-- menu.lua
-- The lightweight Arcade OS Shell
-- Controls: [Left] Prev, [Center] Launch, [Right] Next

-- Kiosk machines should never expose the menu UI.
if _G.ARCADE_KIOSK then
    return
end

local games = {
    { name = "Blackjack", cmd = "blackjack" },
    { name = "Baccarat", cmd = "baccarat" },
    { name = "Super Slots", cmd = "slots" },
    { name = "Horse Race", cmd = "race" },
    { name = "Can't Stop (Free)", cmd = "cant_stop" },
    { name = "RPS Rogue", cmd = "rps_rogue" },
    { name = "Roulette Watch", cmd = "screensavers/roulette" },
    { name = "Update Arcade", cmd = "update" },
    { name = "Exit", cmd = "exit" },
    { name = "Reboot", cmd = "reboot" },
    { name = "Shutdown", cmd = "shutdown" }
}

local selected = 1
local w, h = term.getSize()

local input = require("input")
local credits = require("credits")
local audio = require("audio")

local function drawHeader()
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.yellow)
    term.setCursorPos(1, 1)
    term.clearLine()
    term.setCursorPos(2, 1)
    term.write("ARCADE OS")
    
    local c = credits.get()
    local name = credits.getName()

    local rightText = "Credits: " .. c
    if name then
        rightText = name .. " | " .. rightText
    end

    term.setCursorPos(w - #rightText - 1, 1)
    term.write(rightText)
end

local function drawMenu()
    term.setBackgroundColor(colors.black)
    term.clear()
    drawHeader()
    
    local centerY = math.floor(h / 2)
    
    for i, game in ipairs(games) do
        local y = centerY - 2 + i
        if y >= 2 and y < h then
            term.setCursorPos(2, y)
            if i == selected then
                term.setTextColor(colors.lime)
                term.write("> " .. game.name .. " <")
            else
                term.setTextColor(colors.white)
                term.write("  " .. game.name)
            end
        end
    end
    
    -- Footer
    term.setBackgroundColor(colors.gray)
    term.setTextColor(colors.black)
    term.setCursorPos(1, h)
    term.clearLine()
    term.write(" [L] Prev  [C] Launch  [R] Next  [S] Monitor")
end

local function launchGame()
    local game = games[selected]
    term.setBackgroundColor(colors.black)
    term.clear()
    term.setCursorPos(1, 1)
    
    if game.cmd == "reboot" then
        os.reboot()
    elseif game.cmd == "shutdown" then
        os.shutdown()
    elseif game.cmd == "exit" then
        return true
    else
        if fs.exists(game.cmd .. ".lua") then
            -- Persist selection so this game auto-loads at startup.
            local f = fs.open(".arcade_config", "w")
            if f then
                f.write(game.cmd)
                f.close()
            end
            shell.run(game.cmd)
        else
            print("Game not installed: " .. game.cmd)
            sleep(1)
        end
    end
    return false
end

local function main()
    while true do
        drawMenu()
        
        local event, p1 = os.pullEvent()
        local button = input.getButton(event, p1)
        
        if button == "LEFT" then
            selected = selected - 1
            if selected < 1 then selected = #games end
            audio.playClick()
            if event == "redstone" then sleep(0.2) end
        elseif button == "RIGHT" then
            selected = selected + 1
            if selected > #games then selected = 1 end
            audio.playClick()
            if event == "redstone" then sleep(0.2) end
        elseif button == "CENTER" then
            audio.playConfirm()
            if launchGame() then break end
            if event == "redstone" then sleep(0.2) end
        elseif event == "char" and p1:lower() == "s" then
            local m = peripheral.find("monitor")
            if m then
                audio.playConfirm()
                term.setBackgroundColor(colors.black)
                term.setTextColor(colors.white)
                term.clear()
                term.setCursorPos(1, 1)
                print("Monitor detected.")
                print("Rebooting to switch display...")
                sleep(1)
                os.reboot()
            else
                audio.playLose()
            end
        elseif event == "disk" then
             local name = credits.getName()
             local amount = credits.get()
             if name then
                audio.playConfirm()
                local popupW, popupH = 24, 7
                local px = math.floor((w - popupW) / 2)
                local py = math.floor((h - popupH) / 2)
                
                -- Draw box
                paintutils.drawFilledBox(px, py, px + popupW, py + popupH, colors.blue)
                term.setTextColor(colors.yellow)
                term.setCursorPos(px + 2, py + 1)
                term.write("WELCOME BACK!")
                
                term.setTextColor(colors.white)
                term.setCursorPos(px + 2, py + 3)
                term.write(name)
                
                term.setCursorPos(px + 2, py + 5)
                term.write("Credits: " .. amount)
                
                sleep(3)
             end
        end
    end
end

main()

]])

writeFile('race.lua', [[
-- race.lua
-- ASCII Horse Racing (3-button)
-- Controls: [Left]=Horse 1, [Center]=Horse 2, [Right]=Horse 3
-- Keyboard exit: [Backspace] or [E]
-- Optional payout pulse: enable PAYOUT_PULSE below.

local input = require("input")
local creditsAPI = require("credits")
local audio = require("audio")

math.randomseed(os.epoch("utc"))

local w, h = term.getSize()

--------------------------------------------------------------------------------
-- CONFIG
--------------------------------------------------------------------------------

local BET_COST = 5

-- If you want to drive a dispenser/dropper, set this true.
-- (The arcade already pays via the Credits card system by default.)
local PAYOUT_PULSE = false
local PAYOUT_SIDE = "bottom"
local PAYOUT_PULSE_SECONDS = 0.12

-- Track will auto-fit the current terminal/monitor width.
local MIN_TRACK_LEN = 18
local TRACK_PADDING = 20 -- room for name/odds on the left

-- Odds are fractional (profit = bet * num/den; total return = bet + profit)
-- These are intentionally a little "unfair" (overround) like an arcade book.
local horses = {
    {
        idx = 1,
        name = "COPPER COMET",
        color = colors.orange,
        oddsNum = 4,
        oddsDen = 5,
        style = "STEADY",
    },
    {
        idx = 2,
        name = "LEDGER LIZARD",
        color = colors.lightGray,
        oddsNum = 7,
        oddsDen = 5,
        style = "CLOSER",
    },
    {
        idx = 3,
        name = "NEON PANIC",
        color = colors.purple,
        oddsNum = 3,
        oddsDen = 1,
        style = "CHAOS",
    },
}

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function clamp(n, lo, hi)
    if n < lo then return lo end
    if n > hi then return hi end
    return n
end

local function clear(bg)
    term.setBackgroundColor(bg or colors.black)
    term.setTextColor(colors.white)
    term.clear()
    term.setCursorPos(1, 1)
end

local function drawCenter(y, text, fg, bg)
    if bg then term.setBackgroundColor(bg) end
    if fg then term.setTextColor(fg) end
    local x = math.max(1, math.floor((w - #text) / 2) + 1)
    term.setCursorPos(x, y)
    term.write(text)
end

local function waitButtonOrExit()
    while true do
        local event, p1 = os.pullEvent()
        local button = input.getButton(event, p1)
        if button then
            if event == "redstone" then sleep(0.2) end
            return button
        end
        if event == "key" then
            local name = keys.getName(p1)
            if name == "backspace" then return "EXIT" end
        elseif event == "char" then
            if tostring(p1):lower() == "e" then return "EXIT" end
        elseif event == "terminate" then
            return "EXIT"
        end
    end
end

local function waitForBreakEvent(seconds)
    local timerId
    if seconds and seconds > 0 then
        timerId = os.startTimer(seconds)
    end

    while true do
        local event, p1 = os.pullEvent()

        if event == "disk" then
            return { type = "disk", event = event, p1 = p1 }
        end

        local button = input.getButton(event, p1)
        if button then
            if event == "redstone" then sleep(0.2) end
            return { type = "button", button = button, event = event, p1 = p1 }
        end

        if event == "key" then
            local name = keys.getName(p1)
            if name == "backspace" then return { type = "exit" } end
            return { type = "key", event = event, p1 = p1 }
        elseif event == "char" then
            if tostring(p1):lower() == "e" then return { type = "exit" } end
            return { type = "key", event = event, p1 = p1 }
        elseif event == "terminate" then
            return { type = "exit" }
        end

        if timerId and event == "timer" and p1 == timerId then
            return { type = "timeout" }
        end
    end
end

local function runAttractModeRace()
    while true do
        clear(colors.black)
        drawHeader(0)
        drawCenter(3, "ATTRACTION MODE", colors.yellow, colors.black)
        drawCenter(5, "Demo Race - Insert Disk / Press Any Button", colors.white, colors.black)
        local brk = waitForBreakEvent(0.8)
        if brk and brk.type ~= "timeout" then return brk end

        local trackLen = computeTrackLen()
        local positions = { 1, 1, 1 }
        local winner = nil

        local raceDelay = 0.10
        while not winner do
            for i, horse in ipairs(horses) do
                local progress = positions[i] / trackLen
                local step = stepForHorse(horse, progress)
                positions[i] = clamp(positions[i] + step, 1, trackLen)
                if positions[i] >= trackLen then
                    winner = i
                    break
                end
            end

            drawTrack(trackLen, positions)
            drawCenter(h - 2, "ATTRACTION MODE - Insert Disk / Press Any Button", colors.gray, colors.black)
            audio.playShuffle()
            brk = waitForBreakEvent(raceDelay)
            if brk and brk.type ~= "timeout" then return brk end
        end

        drawTrack(trackLen, positions, winner)
        drawCenter(h - 2, "ATTRACTION MODE - Winner: " .. horses[winner].name, colors.lime, colors.black)
        audio.playWin()
        brk = waitForBreakEvent(2.0)
        if brk and brk.type ~= "timeout" then return brk end
    end
end

local function oddsString(h)
    return tostring(h.oddsNum) .. ":" .. tostring(h.oddsDen)
end

local function totalReturn(bet, h)
    local profit = bet * (h.oddsNum / h.oddsDen)
    return math.floor(bet + profit)
end

local function pulsePayout(count)
    if not PAYOUT_PULSE then return end
    for _ = 1, count do
        redstone.setOutput(PAYOUT_SIDE, true)
        sleep(PAYOUT_PULSE_SECONDS)
        redstone.setOutput(PAYOUT_SIDE, false)
        sleep(PAYOUT_PULSE_SECONDS)
    end
end

--------------------------------------------------------------------------------
-- RACE LOGIC (PERSONALITIES)
--------------------------------------------------------------------------------

local function stepForHorse(h, progress)
    -- progress: 0..1 (how far the race has advanced for that horse)
    -- returns step delta (can be 0 or negative for CHAOS)

    if h.style == "STEADY" then
        -- Consistent pace. Rare 2-step burst.
        local step = 0
        if math.random() < 0.68 then step = 1 end
        if step == 1 and math.random() < 0.08 then step = 2 end
        return step
    end

    if h.style == "CLOSER" then
        -- Slow early, strong finish.
        local p = 0.48
        local burst = 0.06
        if progress >= 0.60 then
            p = 0.74
            burst = 0.14
        elseif progress >= 0.35 then
            p = 0.58
            burst = 0.09
        end

        local step = 0
        if math.random() < p then step = 1 end
        if step == 1 and math.random() < burst then step = 2 end
        return step
    end

    -- CHAOS
    -- Mostly awkward, occasionally ridiculous.
    local roll = math.random(1, 100)
    if roll <= 18 then return 0 end
    if roll <= 30 then return -1 end
    if roll <= 82 then return 1 end
    if roll <= 95 then return 2 end
    return 3
end

--------------------------------------------------------------------------------
-- DRAWING
--------------------------------------------------------------------------------

local function computeTrackLen()
    local trackLen = w - TRACK_PADDING
    trackLen = clamp(trackLen, MIN_TRACK_LEN, 60)
    return trackLen
end

local function drawHeader(credits)
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.yellow)
    term.setCursorPos(1, 1)
    term.clearLine()
    term.setCursorPos(2, 1)
    term.write("HORSE RACE")

    local cText = "Credits: " .. tostring(credits)
    term.setTextColor(colors.white)
    term.setCursorPos(math.max(1, w - #cText + 1), 1)
    term.write(cText)
end

local function drawBetScreen(credits)
    clear(colors.black)
    drawHeader(credits)

    drawCenter(3, "PLACE YOUR BET", colors.lime, colors.black)
    drawCenter(5, "Bet Cost: " .. tostring(BET_COST), colors.white, colors.black)

    local y = 7
    term.setCursorPos(3, y)
    term.setTextColor(colors.gray)
    term.write("[L] " .. horses[1].name .. " (" .. oddsString(horses[1]) .. ")")

    term.setCursorPos(3, y + 2)
    term.write("[C] " .. horses[2].name .. " (" .. oddsString(horses[2]) .. ")")

    term.setCursorPos(3, y + 4)
    term.write("[R] " .. horses[3].name .. " (" .. oddsString(horses[3]) .. ")")

    term.setCursorPos(3, y + 7)
    term.setTextColor(colors.yellow)
    term.write("Win returns (total): ")

    term.setCursorPos(3, y + 8)
    term.setTextColor(colors.white)
    term.write("L=" .. totalReturn(BET_COST, horses[1]) .. "  C=" .. totalReturn(BET_COST, horses[2]) .. "  R=" .. totalReturn(BET_COST, horses[3]))

    term.setCursorPos(3, h - 2)
    term.setTextColor(colors.gray)
    term.write("Keyboard: [E]/[Backspace] to exit")
end

local function drawTrack(trackLen, positions, winnerIdx)
    clear(colors.black)

    local baseY = 3
    for i, horse in ipairs(horses) do
        local labelY = baseY + (i - 1) * 4
        local laneY = labelY + 1

        term.setCursorPos(2, labelY)
        term.setTextColor(colors.white)
        term.write(horse.name)

        term.setCursorPos(w - 10, labelY)
        term.setTextColor(colors.gray)
        term.write(oddsString(horse))

        term.setCursorPos(2, laneY)
        term.setTextColor(colors.gray)
        term.write(string.rep("-", trackLen) .. "|")

        local pos = positions[i]
        local drawX = 2 + clamp(pos, 1, trackLen - 2)
        term.setCursorPos(drawX, laneY)
        term.setTextColor(horse.color)
        term.write("@>")

        if winnerIdx and winnerIdx == i then
            term.setCursorPos(2, laneY + 1)
            term.setTextColor(colors.lime)
            term.write("WINNER")
        end
    end
end

--------------------------------------------------------------------------------
-- MAIN
--------------------------------------------------------------------------------

local function main()
    while true do
        local credits = creditsAPI.get()
        drawBetScreen(credits)

        local brk = waitForBreakEvent(8)
        if brk and brk.type == "timeout" then
            brk = runAttractModeRace()
        end

        if brk and brk.type == "exit" then
            break
        end
        if not brk or brk.type == "disk" then
            -- disk inserted / changed: just redraw bet screen
            goto continue_main
        end

        local button = brk.button

        local betHorse = nil
        if button == "LEFT" then betHorse = 1 end
        if button == "CENTER" then betHorse = 2 end
        if button == "RIGHT" then betHorse = 3 end

        if betHorse == nil then
            audio.playError()
        else
            if credits ~= math.huge and credits < BET_COST then
                audio.playLose()
                drawCenter(h - 4, "Not enough credits!", colors.red, colors.black)
                sleep(1.2)
            else
                audio.playChip()
                creditsAPI.remove(BET_COST)

                local trackLen = computeTrackLen()
                local positions = { 1, 1, 1 }
                local winner = nil

                local raceDelay = 0.12
                while not winner do
                    for i, horse in ipairs(horses) do
                        local progress = positions[i] / trackLen
                        local step = stepForHorse(horse, progress)
                        positions[i] = clamp(positions[i] + step, 1, trackLen)
                        if positions[i] >= trackLen then
                            winner = i
                            break
                        end
                    end

                    drawTrack(trackLen, positions)
                    audio.playShuffle()
                    sleep(raceDelay)
                end

                drawTrack(trackLen, positions, winner)
                term.setCursorPos(2, h - 4)

                if winner == betHorse then
                    audio.playWin()
                    term.setTextColor(colors.lime)
                    local winTotal = totalReturn(BET_COST, horses[winner])
                    local profit = winTotal - BET_COST
                    term.write("YOU WIN! +" .. tostring(profit) .. " credits")

                    creditsAPI.add(winTotal)
                    pulsePayout(profit)
                else
                    audio.playLose()
                    term.setTextColor(colors.red)
                    term.write("YOU LOSE. Winner: " .. horses[winner].name)
                end

                term.setCursorPos(2, h - 2)
                term.setTextColor(colors.gray)
                term.write("Press any button...")
                waitButtonOrExit()
            end
        end

        ::continue_main::
    end

    term.setBackgroundColor(colors.black)
    term.clear()
    if fs.exists("menu.lua") then
        shell.run("menu.lua")
    end
end

main()

]])

writeFile('rps_rogue.lua', [[
-- rps_rogue.lua
-- Rock-Paper-Scissors Roguelike

local w, h = term.getSize()

-- 3-Button Config
local input = require("input")

local function waitForDiskOrTimeout(seconds)
    local timerId
    if seconds and seconds > 0 then
        timerId = os.startTimer(seconds)
    end

    while true do
        local e, p1 = os.pullEvent()

        if e == "disk" then
            return { type = "disk", event = e, p1 = p1 }
        end

        if timerId and e == "timer" and p1 == timerId then
            return { type = "timeout" }
        end
    end
end

local function waitKey()
    while true do
        local e, p1 = os.pullEvent()
        local button = input.getButton(e, p1)
        if button then
            if e == "redstone" then sleep(0.2) end
            return button
        end
    end
end

--------------------------------------------------------------------------------
-- GAME LOGIC
--------------------------------------------------------------------------------

local MOVES = { "Rock", "Paper", "Scissors" }
local BEATS = { Rock = "Scissors", Paper = "Rock", Scissors = "Paper" }

local player = { hp = 20, maxHp = 20, dmg = 3, level = 1 }
local enemy = { hp = 10, maxHp = 10, dmg = 2, name = "Slime" }
local floor = 1
local log = {}

local function addLog(msg)
    table.insert(log, 1, msg)
    if #log > 5 then table.remove(log) end
end

local function generateEnemy()
    local types = {
        {name="Slime", hp=10, dmg=2},
        {name="Goblin", hp=15, dmg=3},
        {name="Orc", hp=25, dmg=4},
        {name="Dragon", hp=50, dmg=8}
    }
    local idx = math.min(#types, math.floor((floor-1)/3) + 1)
    if floor > 10 then idx = 4 end
    
    local base = types[idx]
    enemy = {
        name = base.name,
        hp = base.hp + math.floor(floor * 1.5),
        maxHp = base.hp + math.floor(floor * 1.5),
        dmg = base.dmg + math.floor(floor * 0.5)
    }
end

local function resolveRound(pMove, eMove)
    addLog("You: " .. pMove .. " vs " .. eMove)
    
    if pMove == eMove then
        addLog("Draw!")
    elseif BEATS[pMove] == eMove then
        addLog("Hit! Dealt " .. player.dmg .. " dmg.")
        enemy.hp = enemy.hp - player.dmg
        audio.playClick()
    else
        addLog("Ouch! Took " .. enemy.dmg .. " dmg.")
        player.hp = player.hp - enemy.dmg
        audio.playLose()
    end
end

--------------------------------------------------------------------------------
-- UI
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- UI
--------------------------------------------------------------------------------

local function drawText(x, y, text, fg, bg)
    term.setCursorPos(x, y)
    if fg then term.setTextColor(fg) end
    if bg then term.setBackgroundColor(bg) end
    term.write(text)
end

local function drawFooter(c1, c2, c3)
    local colW = math.floor(w / 3)
    
    -- Left Button
    term.setCursorPos(1, h)
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", colW))
    drawText(math.floor(colW/2 - #c1/2)+1, h, c1, colors.white, colors.red)
    
    -- Center Button
    term.setCursorPos(colW + 1, h)
    term.setBackgroundColor(colors.yellow)
    term.setTextColor(colors.black)
    term.write(string.rep(" ", colW))
    drawText(colW + math.floor(colW/2 - #c2/2)+1, h, c2, colors.black, colors.yellow)
    
    -- Right Button
    term.setCursorPos(colW * 2 + 1, h)
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", w - (colW*2)))
    drawText(colW*2 + math.floor((w - colW*2)/2 - #c3/2)+1, h, c3, colors.white, colors.blue)
end

local function drawBar(label, val, max, y, color)
    term.setCursorPos(2, y)
    term.setTextColor(color)
    term.write(label .. ": " .. val .. "/" .. max)
    
    local barW = 10
    local fill = math.ceil((val/max) * barW)
    term.setCursorPos(2, y+1)
    term.setBackgroundColor(color)
    term.write(string.rep(" ", fill))
    term.setBackgroundColor(colors.gray)
    term.write(string.rep(" ", barW - fill))
    term.setBackgroundColor(colors.black)
end

local function drawUI()
    term.setBackgroundColor(colors.black)
    term.clear()
    
    -- Header
    term.setCursorPos(1, 1)
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.clearLine()
    term.write(" FLOOR " .. floor .. " - " .. enemy.name)
    
    -- Stats
    drawBar("PLAYER", player.hp, player.maxHp, 3, colors.lime)
    drawBar("ENEMY", enemy.hp, enemy.maxHp, 3, colors.red)
    
    -- Enemy is on the right
    term.setCursorPos(w - 15, 3)
    term.setTextColor(colors.red)
    term.write(enemy.name)
    term.setCursorPos(w - 15, 4)
    term.write("HP: " .. enemy.hp .. "/" .. enemy.maxHp)
    
    -- Log
    term.setCursorPos(2, 8)
    term.setTextColor(colors.white)
    term.write("--- LOG ---")
    for i, msg in ipairs(log) do
        term.setCursorPos(2, 9 + i)
        term.setTextColor(colors.lightGray)
        term.write(msg)
    end
    
    -- Controls
    term.setCursorPos(1, h)
    drawFooter("Rock", "Paper", "Scissors")
end

local function drawUpgradeMenu()
    term.setBackgroundColor(colors.black)
    term.clear()
    term.setCursorPos(1, 1)
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.yellow)
    term.clearLine()
    term.write(" LEVEL UP! Choose Upgrade:")
    
    term.setCursorPos(1, h)
    drawFooter("Heal Full", "+5 Max HP", "+1 Damage")
end

--------------------------------------------------------------------------------
-- MAIN LOOP
--------------------------------------------------------------------------------

local creditsAPI = require("credits")
local audio = require("audio")

local function main()
    while creditsAPI.get() < 5 do
        term.setBackgroundColor(colors.black)
        term.clear()
        term.setCursorPos(1, 1)
        term.setBackgroundColor(colors.red)
        term.setTextColor(colors.white)
        term.clearLine()
        term.write(" RPS ROGUE ")

        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.setCursorPos(2, math.floor(h/2) - 2)
        term.write("Insert Coin: 5 Credits")
        term.setCursorPos(2, math.floor(h/2))
        term.setTextColor(colors.gray)
        term.write("ATTRACTION MODE - Insert Disk to Play")

        -- Simple demo text that cycles until a disk is inserted.
        local demoLines = {
            "Rock beats Scissors",
            "Paper beats Rock",
            "Scissors beats Paper",
            "Level up and keep going!",
        }

        for i = 1, #demoLines do
            term.setCursorPos(2, math.floor(h/2) + 2)
            term.setTextColor(colors.yellow)
            term.clearLine()
            term.write(demoLines[i])
            local brk = waitForDiskOrTimeout(1.0)
            if brk and brk.type == "disk" then
                break
            end
        end
    end
    creditsAPI.remove(5)

    generateEnemy()
    
    while true do
        if player.hp <= 0 then
            term.clear()
            term.setCursorPos(1, h/2)
            term.setTextColor(colors.red)
            term.write("GAME OVER")
            term.setCursorPos(1, h/2 + 1)
            term.write("Reached Floor " .. floor)
            audio.playLose()
            sleep(3)
            break
        end
        
        if enemy.hp <= 0 then
            -- Victory
            floor = floor + 1
            player.level = player.level + 1
            creditsAPI.add(5) -- Reward for clearing floor
            audio.playWin()
            
            -- Upgrade
            drawUpgradeMenu()
            local key = waitKey()
            if key == "LEFT" then
                player.hp = player.maxHp
            elseif key == "CENTER" then
                player.maxHp = player.maxHp + 5
                player.hp = player.hp + 5
            elseif key == "RIGHT" then
                player.dmg = player.dmg + 1
            end
            audio.playConfirm()
            
            generateEnemy()
            log = {}
            addLog("Floor " .. floor .. " start!")
        else
            drawUI()
            local key = waitKey()
            local pMove = nil
            if key == "LEFT" then pMove = "Rock"
            elseif key == "CENTER" then pMove = "Paper"
            elseif key == "RIGHT" then pMove = "Scissors" end
            
            if pMove then
                local eMove = MOVES[math.random(1, 3)]
                resolveRound(pMove, eMove)
            end
        end
    end
    
    if fs.exists("menu.lua") then shell.run("menu.lua") end
end

main()

]])

writeFile('screensavers/bounce.lua', [[
-- bounce.lua
-- Simple Bouncing DVD Logo Screensaver

local term = term.current()
local width, height = term.getSize()
local x, y = math.floor(width / 2), math.floor(height / 2)
local dx, dy = 1, 1
local color = colors.red

local colorsList = {colors.red, colors.orange, colors.yellow, colors.green, colors.blue, colors.purple, colors.cyan}

while true do
    term.setBackgroundColor(colors.black)
    term.clear()
    
    term.setCursorPos(x, y)
    term.setTextColor(color)
    term.write("O")
    
    x = x + dx
    y = y + dy
    
    if x <= 1 or x >= width then
        dx = -dx
        color = colorsList[math.random(#colorsList)]
    end
    
    if y <= 1 or y >= height then
        dy = -dy
        color = colorsList[math.random(#colorsList)]
    end
    
    -- Check for input to exit
    local timer = os.startTimer(0.1)
    local event, p1 = os.pullEvent()
    if event == "key" or event == "mouse_click" or event == "monitor_touch" or event == "disk" then
        return -- Exit screensaver
    end
end

]])

writeFile('screensavers/roulette.lua', [[
-- roulette.lua
-- Roulette Wheel Screensaver for Arcade OS
-- Ambient spinning wheel

local term = term.current()
local w, h = term.getSize()

-- European Roulette Wheel Sequence
local WHEEL = {
    0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 
    11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 
    22, 18, 29, 7, 28, 12, 35, 3, 26
}

local REDS = {
    [1]=true, [3]=true, [5]=true, [7]=true, [9]=true, [12]=true,
    [14]=true, [16]=true, [18]=true, [19]=true, [21]=true, [23]=true,
    [25]=true, [27]=true, [30]=true, [32]=true, [34]=true, [36]=true
}

local function getNumberColor(num)
    if num == 0 then return colors.green end
    if REDS[num] then return colors.red end
    return colors.black -- ComputerCraft black is actually black
end

-- Helper to handle wait and input check
local function wait(seconds)
    local timer = os.startTimer(seconds)
    while true do
        local event, p1 = os.pullEvent()
        if event == "timer" and p1 == timer then
            return true
        elseif event == "key" or event == "mouse_click" or 
               event == "monitor_touch" or event == "disk" then
            return false -- Input detected, exit
        end
    end
end

local function drawView(offsetIndex)
    term.setBackgroundColor(colors.black)
    term.clear()
    
    local centerY = math.floor(h/2)
    local itemWidth = 5
    local visibleItems = math.ceil(w / itemWidth) + 2
    local centerScreen = math.floor(w/2)
    
    -- Draw Pointer
    term.setTextColor(colors.yellow)
    term.setCursorPos(centerScreen, centerY - 2)
    term.write("v")
    term.setCursorPos(centerScreen, centerY + 2)
    term.write("^")
    
    -- Draw Wheel Strip
    -- offsetIndex is the index of the number currently at center
    -- We need to draw neighbors to the left and right
    
    for i = -math.floor(visibleItems/2), math.floor(visibleItems/2) do
        -- Calculate index in WHEEL (1-based wrapping)
        local idx = ((offsetIndex + i - 1) % #WHEEL) + 1
        local num = WHEEL[idx]
        local bg = getNumberColor(num)
        
        -- Screen X position
        -- If i=0 (center item), x should be centerScreen - (itemWidth/2) approximately
        local x = math.floor(centerScreen + (i * itemWidth) - (itemWidth/2))
        
        -- Draw block
        if x + itemWidth > 1 and x <= w then
             term.setBackgroundColor(bg)
             term.setTextColor(colors.white)
             
             -- Draw box
             for dy = -1, 1 do
                 if x < 1 then 
                     -- Partial draw left
                 else
                     term.setCursorPos(x, centerY + dy)
                     
                     local text = tostring(num)
                     local pad = math.floor((itemWidth - #text)/2)
                     local str = string.rep(" ", pad) .. text .. string.rep(" ", itemWidth - #text - pad)
                     
                     if dy ~= 0 then str = string.rep(" ", itemWidth) end -- Only text on middle line
                     
                     -- Handle clipping
                     if x + #str - 1 > w then
                         str = string.sub(str, 1, w - x + 1)
                     end
                     if x < 1 then
                          str = string.sub(str, 2 - x)
                          term.setCursorPos(1, centerY + dy)
                     end
                     
                     term.write(str)
                 end
             end
        end
    end
    
    -- Decor: Spinning ASCII Wheel (Visual only)
    -- Just a rotating character or something above
    term.setBackgroundColor(colors.black)
    local spinChars = {"|", "/", "-", "\\"}
    local spinFrame = math.floor(os.clock() * 10) % 4 + 1
    -- drawText(centerScreen, centerY - 4, spinChars[spinFrame], colors.gray, colors.black)
end

while true do
    -- 1. Spin Phase
    local speed = 0.05 -- Delay per frame (lower is faster)
    local friction = 1.05 -- Multiplier to speed (slow down)
    local currentIndex = math.random(1, #WHEEL)
    local totalSpins = math.random(30, 60) -- Number of ticks to spin
    
    -- Accelerate / Constant
    local runTicks = 0
    while runTicks < totalSpins do
        currentIndex = (currentIndex % #WHEEL) + 1
        
        drawView(currentIndex)
        
        if not wait(0.05) then return end -- Fixed fast speed
        
        runTicks = runTicks + 1
    end
    
    -- Decelerate
    while speed < 0.8 do
        currentIndex = (currentIndex % #WHEEL) + 1
        
        drawView(currentIndex)
        
        if not wait(speed) then return end
        
        speed = speed * friction
    end
    
    -- Stop & Highlight
    local winner = WHEEL[currentIndex]
    local wColor = getNumberColor(winner)
    
    -- Blink effect
    for i=1, 6 do
        term.setCursorPos(math.floor(w/2)-2, math.floor(h/2)-1)
        if i % 2 == 0 then
            term.setBackgroundColor(wColor)
            term.setTextColor(colors.white)
        else
            term.setBackgroundColor(colors.white)
            term.setTextColor(wColor)
        end
        term.write(string.format(" %2d  ", winner))
        
        if not wait(0.3) then return end
    end
    
    -- Hold
    if not wait(3) then return end
end

]])

writeFile('setup.lua', [[
-- setup.lua
-- Initial Configuration Menu
-- Select the game to permanently install on this machine

local games = {
    { name = "Blackjack", cmd = "blackjack" },
    { name = "Baccarat", cmd = "baccarat" },
    { name = "Super Slots", cmd = "slots" },
    { name = "Horse Race", cmd = "race" },
    { name = "Can't Stop (Free)", cmd = "cant_stop" },
    { name = "Can't Stop (Dedicated Spawn)", cmd = "cant_stop_kiosk" },
    { name = "RPS Rogue", cmd = "rps_rogue" },
    { name = "Roulette Watch", cmd = "screensavers/roulette" },
    { name = "Exchange", cmd = "exchange" },
    { name = "Cashier System", cmd = "cashier" }
}

local selected = 1
local w, h = term.getSize()

local input = require("input")
local audio = require("audio")

local function drawHeader()
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.setCursorPos(1, 1)
    term.clearLine()
    term.setCursorPos(2, 1)
    term.write("SYSTEM SETUP - ONE TIME ONLY")
end

local function drawMenu()
    term.setBackgroundColor(colors.black)
    term.clear()
    drawHeader()
    
    local centerY = math.floor(h / 2)
    
    term.setCursorPos(2, 3)
    term.setTextColor(colors.gray)
    term.write("Select Game to Install:")

    for i, game in ipairs(games) do
        local y = centerY - 1 + i
        if y >= 4 and y < h then
            term.setCursorPos(2, y)
            if i == selected then
                term.setTextColor(colors.lime)
                term.write("> " .. game.name .. " <")
            else
                term.setTextColor(colors.white)
                term.write("  " .. game.name)
            end
        end
    end
    
    -- Footer
    term.setBackgroundColor(colors.gray)
    term.setTextColor(colors.black)
    term.setCursorPos(1, h)
    term.clearLine()
    term.write(" [L] Prev  [C] INSTALL  [R] Next")
end

local function installGame()
    local game = games[selected]
    term.setBackgroundColor(colors.black)
    term.clear()
    term.setCursorPos(1, 1)
    print("Installing " .. game.name .. "...")

    -- Dedicated Spawn preset
    if game.cmd == "cant_stop_kiosk" then
        local file = fs.open(".arcade_config", "w")
        file.write("cant_stop")
        file.close()

        local k = fs.open(".kiosk_mode", "w")
        k.write("1")
        k.close()

        local kg = fs.open(".kiosk_game", "w")
        kg.write("cant_stop")
        kg.close()
    else
        local file = fs.open(".arcade_config", "w")
        file.write(game.cmd)
        file.close()
    end
    
    print("Configuration saved.")
    print("Rebooting in 2 seconds...")
    sleep(2)
    os.reboot()
end

local function main()
    while true do
        drawMenu()
        
        local event, p1 = os.pullEvent()
        local button = input.getButton(event, p1)
        
        if button == "LEFT" then
            selected = selected - 1
            if selected < 1 then selected = #games end
            audio.playClick()
            if event == "redstone" then sleep(0.2) end
        elseif button == "RIGHT" then
            selected = selected + 1
            if selected > #games then selected = 1 end
            audio.playClick()
            if event == "redstone" then sleep(0.2) end
        elseif button == "CENTER" then
            audio.playConfirm()
            installGame()
            break
        end
    end
end

main()

]])

writeFile('slots.lua', [[
-- slots.lua
-- 3-Button Slot Machine (Multiplayer Edition)

local w, h = term.getSize()
local cx, cy = math.floor(w / 2), math.floor(h / 2)

local input = require("input")
local creditsAPI = require("credits")
local audio = require("audio")

local function waitKey()
    while true do
        local e, p1 = os.pullEvent()
        local button = input.getButton(e, p1)
        if button then
            if e == "redstone" then sleep(0.2) end
            return button
        end
    end
end

local function drawText(x, y, text, fg, bg)
    term.setCursorPos(x, y)
    if fg then term.setTextColor(fg) end
    if bg then term.setBackgroundColor(bg) end
    term.write(text)
end

local function drawCenter(y, text, fg, bg)
    local x = math.floor((w - #text)/2) + 1
    drawText(x, y, text, fg, bg)
end

--------------------------------------------------------------------------------
-- UI PRIMITIVES ("graphics" via term/blit)
--------------------------------------------------------------------------------

local HAS_BLIT = type(term.blit) == "function"

local function clamp(n, lo, hi)
    if n < lo then return lo end
    if n > hi then return hi end
    return n
end

local function toBlit(c)
    if type(colors) == "table" and type(colors.toBlit) == "function" then
        return colors.toBlit(c)
    end
    -- Fallback: most CC installs have colors.toBlit; if not, use white.
    return "0"
end

local function blitFill(x, y, width, height, ch, fg, bg)
    ch = ch or " "
    fg = fg or colors.white
    bg = bg or colors.black
    if width <= 0 or height <= 0 then return end
    if not HAS_BLIT then
        term.setBackgroundColor(bg)
        term.setTextColor(fg)
        for row = 0, height - 1 do
            term.setCursorPos(x, y + row)
            term.write(string.rep(ch, width))
        end
        return
    end
    local text = string.rep(ch, width)
    local fgs = string.rep(toBlit(fg), width)
    local bgs = string.rep(toBlit(bg), width)
    for row = 0, height - 1 do
        term.setCursorPos(x, y + row)
        term.blit(text, fgs, bgs)
    end
end

local function writeAt(x, y, text, fg, bg)
    if not text or #text == 0 then return end
    term.setCursorPos(x, y)
    if bg then term.setBackgroundColor(bg) end
    if fg then term.setTextColor(fg) end
    term.write(text)
end

local function frameRect(x, y, width, height, borderBg, innerBg)
    if width <= 1 or height <= 1 then return end
    borderBg = borderBg or colors.gray
    innerBg = innerBg or colors.black

    blitFill(x, y, width, 1, " ", colors.white, borderBg)
    blitFill(x, y + height - 1, width, 1, " ", colors.white, borderBg)
    blitFill(x, y + 1, 1, height - 2, " ", colors.white, borderBg)
    blitFill(x + width - 1, y + 1, 1, height - 2, " ", colors.white, borderBg)
    blitFill(x + 1, y + 1, width - 2, height - 2, " ", colors.white, innerBg)
end

local function shadowRect(x, y, width, height, shadowBg)
    shadowBg = shadowBg or colors.black
    blitFill(x + 1, y + height, width, 1, " ", colors.white, shadowBg)
    blitFill(x + width, y + 1, 1, height, " ", colors.white, shadowBg)
end

local function centerTextIn(x, y, width, text, fg, bg)
    local tx = x + math.floor((width - #text) / 2)
    writeAt(tx, y, text, fg, bg)
end

--------------------------------------------------------------------------------
-- GAME CONFIG
--------------------------------------------------------------------------------

local SYMBOLS = {"Cherry", "Lemon", "Orange", "Plum", "Bell", "Bar", "7"}
local COLORS = {
    Cherry = colors.red, Lemon = colors.yellow, Orange = colors.orange,
    Plum = colors.purple, Bell = colors.gold or colors.yellow,
    Bar = colors.lightGray, ["7"] = colors.red
}
local CHARS = {
    Cherry = "@", Lemon = "O", Orange = "O", Plum = "%",
    Bell = "A", Bar = "=", ["7"] = "7"
}
local PAYOUTS = {
    Cherry = 5, Lemon = 10, Orange = 20, Plum = 50,
    Bell = 100, Bar = 250, ["7"] = 500
}

local REELS = {}
for i=1,3 do
    REELS[i] = {}
    for j=1,32 do
        local r = math.random()
        local s
        if r < 0.05 then s = "7"
        elseif r < 0.15 then s = "Bar"
        elseif r < 0.25 then s = "Bell"
        elseif r < 0.40 then s = "Plum"
        elseif r < 0.60 then s = "Orange"
        elseif r < 0.80 then s = "Lemon"
        else s = "Cherry" end
        table.insert(REELS[i], s)
    end
end

--------------------------------------------------------------------------------
-- DRAWING
--------------------------------------------------------------------------------

local function drawFooter(c1, c2, c3)
    local colW = math.floor(w / 3)
    
    -- Left Button
    term.setCursorPos(1, h)
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", colW))
    drawText(math.floor(colW/2 - #c1/2)+1, h, c1, colors.white, colors.red)
    
    -- Center Button
    term.setCursorPos(colW + 1, h)
    term.setBackgroundColor(colors.yellow)
    term.setTextColor(colors.black)
    term.write(string.rep(" ", colW))
    drawText(colW + math.floor(colW/2 - #c2/2)+1, h, c2, colors.black, colors.yellow)
    
    -- Right Button
    term.setCursorPos(colW * 2 + 1, h)
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", w - (colW*2)))
    drawText(colW*2 + math.floor((w - colW*2)/2 - #c3/2)+1, h, c3, colors.white, colors.blue)
end

local reelPos = {1, 1, 1}

local function drawReel(idx, x, y)
    -- Reel window: framed 7x7 with 3 visible symbols.
    local reelW, reelH = 7, 7
    shadowRect(x, y, reelW, reelH, colors.black)
    frameRect(x, y, reelW, reelH, colors.gray, colors.white)

    local innerX, innerY = x + 1, y + 1
    local innerW, innerH = reelW - 2, reelH - 2

    -- Subtle inner shading band
    blitFill(innerX, innerY, innerW, 1, " ", colors.white, colors.lightGray)
    blitFill(innerX, innerY + innerH - 1, innerW, 1, " ", colors.white, colors.lightGray)

    local rowYs = { innerY + 1, innerY + 2, innerY + 3 }
    for i = 0, 2 do
        local pos = (reelPos[idx] + i - 1) % #REELS[idx] + 1
        local sym = REELS[idx][pos]
        local yRow = rowYs[i + 1]

        -- highlight the center row slightly
        local bg = (i == 1) and colors.white or colors.lightGray
        blitFill(innerX, yRow, innerW, 1, " ", colors.white, bg)

        local face = " " .. CHARS[sym] .. CHARS[sym] .. CHARS[sym] .. " "
        centerTextIn(innerX, yRow, innerW, face, COLORS[sym], bg)
    end
end

local function drawMachine(bet, message, currentPlayerName, currentCredits)
    -- Small terminal fallback
    if w < 34 or h < 19 then
        term.setBackgroundColor(colors.black)
        term.clear()
        drawCenter(1, " SUPER SLOTS ", colors.yellow, colors.blue)
        drawCenter(3, "Bet: " .. tostring(bet), colors.white, colors.black)
        drawCenter(5, tostring(message), colors.yellow, colors.black)
        if currentPlayerName then
            drawCenter(7, "Player: " .. currentPlayerName, colors.white, colors.black)
            drawCenter(8, "Credits: " .. tostring(currentCredits), colors.gold, colors.black)
        end
        drawFooter("Bet", "Spin", "Exit")
        return
    end

    -- Background (subtle pattern)
    term.setBackgroundColor(colors.black)
    term.clear()
    for y = 2, h - 5, 2 do
        blitFill(1, y, w, 1, " ", colors.white, colors.black)
        blitFill(1, y + 1, w, 1, " ", colors.white, colors.gray)
    end

    -- Top title bar
    blitFill(1, 1, w, 1, " ", colors.white, colors.blue)
    centerTextIn(1, 1, w, " SUPER SLOTS ", colors.yellow, colors.blue)
    writeAt(2, 1, "*", colors.yellow, colors.blue)
    writeAt(w - 1, 1, "*", colors.yellow, colors.blue)

    -- Cabinet frame
    local boxW, boxH = 30, 15
    local bx, by = clamp(cx - math.floor(boxW / 2), 2, w - boxW - 1), clamp(cy - 7, 3, h - boxH - 5)
    shadowRect(bx, by, boxW, boxH, colors.black)
    frameRect(bx, by, boxW, boxH, colors.gray, colors.lightGray)
    blitFill(bx + 1, by + 1, boxW - 2, 1, " ", colors.white, colors.orange)
    centerTextIn(bx + 1, by + 1, boxW - 2, " JACKPOT ", colors.white, colors.orange)

    -- Reels area
    local startX = bx + 4
    local startY = by + 4
    for i = 1, 3 do
        drawReel(i, startX + (i - 1) * 9, startY)
    end

    -- Paylines (left arrows + line highlight across reel windows)
    local payTopY = startY + 2
    local payMidY = startY + 3
    local payBotY = startY + 4
    local arrowX = startX - 2
    local lineX = startX + 1
    local lineW = 3 * 9 - 4

    if bet >= 2 then
        writeAt(arrowX, payTopY, ">", colors.red, colors.lightGray)
        blitFill(lineX, payTopY, lineW, 1, " ", colors.white, colors.red)
    end
    if bet >= 1 then
        writeAt(arrowX, payMidY, ">", colors.red, colors.lightGray)
        blitFill(lineX, payMidY, lineW, 1, " ", colors.white, colors.red)
    end
    if bet >= 3 then
        writeAt(arrowX, payBotY, ">", colors.red, colors.lightGray)
        blitFill(lineX, payBotY, lineW, 1, " ", colors.white, colors.red)
    end

    -- Side info panels
    local infoY = by + boxH + 1
    local infoH = 3
    local leftW = math.min(18, w - 4)
    local rightW = 12

    frameRect(2, infoY, leftW, infoH, colors.gray, colors.black)
    frameRect(w - rightW - 1, infoY, rightW, infoH, colors.gray, colors.black)

    if currentPlayerName then
        writeAt(4, infoY + 1, "Player:", colors.lightGray, colors.black)
        writeAt(12, infoY + 1, tostring(currentPlayerName), colors.white, colors.black)
        writeAt(4, infoY + 2, "Credits:", colors.lightGray, colors.black)
        writeAt(13, infoY + 2, tostring(currentCredits), colors.gold, colors.black)
    else
        writeAt(4, infoY + 1, "Insert card to play", colors.lightGray, colors.black)
    end

    writeAt(w - rightW, infoY + 1, "BET", colors.lightGray, colors.black)
    centerTextIn(w - rightW, infoY + 2, rightW - 1, tostring(bet), colors.white, colors.black)

    -- Message banner
    local msgY = h - 4
    frameRect(2, msgY, w - 2, 2, colors.gray, colors.black)
    centerTextIn(2, msgY + 1, w - 2, tostring(message or ""), colors.yellow, colors.black)

    -- Footer
    drawFooter("Bet", "Spin", "Exit")
end

local function spin(player)
    if creditsAPI.get(player.mountPath) < player.bet then
        return "Not enough credits!"
    end
    
    creditsAPI.remove(player.bet, player.mountPath)
    
    -- Animation
    for i=1,20 do
        for r=1,3 do reelPos[r] = (reelPos[r] % #REELS[r]) + 1 end
        drawMachine(player.bet, "Spinning...", player.name, creditsAPI.get(player.mountPath))
        audio.playShuffle()
        sleep(0.05)
    end
    
    -- Stop one by one
    for r=1,3 do
        for i=1,10 do
            reelPos[r] = (reelPos[r] % #REELS[r]) + 1
            for k=r+1,3 do reelPos[k] = (reelPos[k] % #REELS[k]) + 1 end
            drawMachine(player.bet, "Spinning...", player.name, creditsAPI.get(player.mountPath))
            sleep(0.05 + i*0.01)
        end
        audio.playSlotStop()
    end
    
    -- Check Win
    local win = 0
    local function getSym(r, offset)
        return REELS[r][(reelPos[r] + offset - 1) % #REELS[r] + 1]
    end
    
    local function checkLine(offset)
        local s1, s2, s3 = getSym(1, offset), getSym(2, offset), getSym(3, offset)
        if s1 == s2 and s2 == s3 then return PAYOUTS[s1] end
        if s1 == "Cherry" and s2 == "Cherry" then return 5 end
        return 0
    end
    
    if player.bet >= 1 then win = win + checkLine(1) end -- Center (offset 1)
    if player.bet >= 2 then win = win + checkLine(0) end -- Top (offset 0)
    if player.bet >= 3 then win = win + checkLine(2) end -- Bottom (offset 2)
    
    if win > 0 then
        creditsAPI.add(win, player.mountPath)
        audio.playWin()
        
        -- Flash Effect
        for i=1,3 do
            drawMachine(player.bet, "WINNER! " .. win, player.name, creditsAPI.get(player.mountPath))
            sleep(0.1)
            term.setBackgroundColor(colors.lime)
            term.clear()
            sleep(0.1)
        end
        return "WINNER! " .. win
    else
        audio.playLose()
        return "Try again!"
    end
end

local function waitForBreakEvent(seconds)
    local timerId
    if seconds and seconds > 0 then
        timerId = os.startTimer(seconds)
    end

    while true do
        local e, p1 = os.pullEvent()

        if e == "disk" then
            return { type = "disk", event = e, p1 = p1 }
        end

        local button = input.getButton(e, p1)
        if button then
            return { type = "button", button = button, event = e, p1 = p1 }
        end

        if e == "key" or e == "char" then
            return { type = "key", event = e, p1 = p1 }
        end

        if timerId and e == "timer" and p1 == timerId then
            return { type = "timeout" }
        end
    end
end

local function runAttractMode()
    local fakeName = "CPU"
    local fakeCredits = 999

    local function computeWin(bet)
        local function getSym(r, offset)
            return REELS[r][(reelPos[r] + offset - 1) % #REELS[r] + 1]
        end
        local function checkLine(offset)
            local s1, s2, s3 = getSym(1, offset), getSym(2, offset), getSym(3, offset)
            if s1 == s2 and s2 == s3 then return PAYOUTS[s1] end
            if s1 == "Cherry" and s2 == "Cherry" then return 5 end
            return 0
        end

        local win = 0
        if bet >= 1 then win = win + checkLine(1) end
        if bet >= 2 then win = win + checkLine(0) end
        if bet >= 3 then win = win + checkLine(2) end
        return win
    end

    local function demoSpinOnce(bet)
        -- Animation
        for _ = 1, 20 do
            for r = 1, 3 do
                reelPos[r] = (reelPos[r] % #REELS[r]) + 1
            end
            drawMachine(bet, "ATTRACTION MODE - Spinning... (Insert Disk)", fakeName, fakeCredits)
            audio.playShuffle()
            local brk = waitForBreakEvent(0.05)
            if brk and brk.type == "disk" then return brk end
        end

        -- Stop one by one
        for r = 1, 3 do
            for i = 1, 10 do
                reelPos[r] = (reelPos[r] % #REELS[r]) + 1
                for k = r + 1, 3 do
                    reelPos[k] = (reelPos[k] % #REELS[k]) + 1
                end
                drawMachine(bet, "ATTRACTION MODE - Spinning... (Insert Disk)", fakeName, fakeCredits)
                local brk = waitForBreakEvent(0.05 + i * 0.01)
                if brk and brk.type == "disk" then return brk end
            end
            audio.playSlotStop()
        end

        local win = computeWin(bet)
        if win > 0 then
            audio.playWin()
            for _ = 1, 3 do
                drawMachine(bet, "ATTRACTION MODE - WINNER! " .. tostring(win), fakeName, fakeCredits)
                local brk = waitForBreakEvent(0.12)
                if brk and brk.type == "disk" then return brk end
                term.setBackgroundColor(colors.lime)
                term.clear()
                brk = waitForBreakEvent(0.08)
                if brk and brk.type == "disk" then return brk end
            end
        else
            audio.playLose()
            drawMachine(bet, "ATTRACTION MODE - Try again! (Insert Disk)", fakeName, fakeCredits)
            local brk = waitForBreakEvent(0.8)
            if brk and brk.type == "disk" then return brk end
        end
        return nil
    end

    while true do
        local bet = math.random(1, 3)
        drawMachine(bet, "ATTRACTION MODE - Insert Disk to Play", nil, nil)
        local brk = waitForBreakEvent(0.6)
        if brk and brk.type == "disk" then return brk end

        brk = demoSpinOnce(bet)
        if brk and brk.type == "disk" then return brk end

        drawMachine(bet, "ATTRACTION MODE - Next spin... (Insert Disk)", nil, nil)
        brk = waitForBreakEvent(0.8)
        if brk and brk.type == "disk" then return brk end
    end
end

--------------------------------------------------------------------------------
-- MAIN LOOP
--------------------------------------------------------------------------------

local function main()
    while true do
        term.setBackgroundColor(colors.black)
        term.clear()
        if w >= 34 and h >= 19 then
            -- Lobby art
            blitFill(1, 1, w, 1, " ", colors.white, colors.blue)
            centerTextIn(1, 1, w, " SUPER SLOTS ", colors.yellow, colors.blue)
            local artX = clamp(cx - 16, 2, w - 32)
            local artY = clamp(cy - 6, 2, h - 12)
            shadowRect(artX, artY, 32, 10, colors.black)
            frameRect(artX, artY, 32, 10, colors.gray, colors.lightGray)
            blitFill(artX + 1, artY + 1, 30, 1, " ", colors.white, colors.orange)
            centerTextIn(artX + 1, artY + 1, 30, " INSERT CARDS ", colors.white, colors.orange)

            frameRect(artX + 4, artY + 3, 7, 5, colors.gray, colors.white)
            frameRect(artX + 13, artY + 3, 7, 5, colors.gray, colors.white)
            frameRect(artX + 22, artY + 3, 7, 5, colors.gray, colors.white)
            centerTextIn(artX + 4, artY + 5, 7, "@@@", colors.red, colors.white)
            centerTextIn(artX + 13, artY + 5, 7, "===", colors.lightGray, colors.white)
            centerTextIn(artX + 22, artY + 5, 7, "777", colors.red, colors.white)

            drawCenter(artY + 10, "Insert Cards (Max 3)", colors.white, colors.black)
            drawCenter(artY + 12, "[C] Start   [R] Exit", colors.gray, colors.black)
        else
            drawCenter(h/2 - 2, "SUPER SLOTS", colors.gold, colors.black)
            drawCenter(h/2, "Insert Cards (Max 3)", colors.white, colors.black)
            drawCenter(h/2 + 2, "[C] Start   [R] Exit", colors.gray, colors.black)
        end
        
        -- Lobby Loop
        local detectedCards = {}
        local attractDelay = 8
        local attractTimer = os.startTimer(attractDelay)
        while true do
            local event, p1 = os.pullEvent()

            if event == "timer" and p1 == attractTimer and #detectedCards == 0 then
                -- CPU demo until a disk is inserted (attract mode)
                runAttractMode()

                -- Redraw lobby after attract mode
                term.setBackgroundColor(colors.black)
                term.clear()
                if w >= 34 and h >= 19 then
                    blitFill(1, 1, w, 1, " ", colors.white, colors.blue)
                    centerTextIn(1, 1, w, " SUPER SLOTS ", colors.yellow, colors.blue)
                    local artX = clamp(cx - 16, 2, w - 32)
                    local artY = clamp(cy - 6, 2, h - 12)
                    shadowRect(artX, artY, 32, 10, colors.black)
                    frameRect(artX, artY, 32, 10, colors.gray, colors.lightGray)
                    blitFill(artX + 1, artY + 1, 30, 1, " ", colors.white, colors.orange)
                    centerTextIn(artX + 1, artY + 1, 30, " INSERT CARDS ", colors.white, colors.orange)

                    frameRect(artX + 4, artY + 3, 7, 5, colors.gray, colors.white)
                    frameRect(artX + 13, artY + 3, 7, 5, colors.gray, colors.white)
                    frameRect(artX + 22, artY + 3, 7, 5, colors.gray, colors.white)
                    centerTextIn(artX + 4, artY + 5, 7, "@@@", colors.red, colors.white)
                    centerTextIn(artX + 13, artY + 5, 7, "===", colors.lightGray, colors.white)
                    centerTextIn(artX + 22, artY + 5, 7, "777", colors.red, colors.white)

                    drawCenter(artY + 10, "Insert Cards (Max 3)", colors.white, colors.black)
                    drawCenter(artY + 12, "[C] Start   [R] Exit", colors.gray, colors.black)
                else
                    drawCenter(h/2 - 2, "SUPER SLOTS", colors.gold, colors.black)
                    drawCenter(h/2, "Insert Cards (Max 3)", colors.white, colors.black)
                    drawCenter(h/2 + 2, "[C] Start   [R] Exit", colors.gray, colors.black)
                end

                -- Refresh cards and reset timer
                detectedCards = creditsAPI.findCards()
                attractTimer = os.startTimer(attractDelay)
            end

            -- Arcade button controls (works for redstone + key-based configs)
            local button = input.getButton(event, p1)
            if button == "CENTER" then
                if #detectedCards > 0 then break end
                drawCenter(h/2 + 4, "No players detected!", colors.red, colors.black)
                sleep(1)
                term.setCursorPos(1, h/2+4) term.clearLine()
                attractTimer = os.startTimer(attractDelay)
            elseif button == "RIGHT" then
                term.setBackgroundColor(colors.black)
                term.clear()
                if fs.exists("menu.lua") then shell.run("menu.lua") end
                return
            end

            if event == "key" then
                local key = keys.getName(p1)
                if key == "enter" or key == "space" then -- Start
                    if #detectedCards > 0 then break end
                    drawCenter(h/2 + 4, "No players detected!", colors.red, colors.black)
                    sleep(1)
                    term.setCursorPos(1, h/2+4) term.clearLine()
                    attractTimer = os.startTimer(attractDelay)
                elseif key == "backspace" or key == "e" then -- Exit
                     term.setBackgroundColor(colors.black)
                     term.clear()
                     if fs.exists("menu.lua") then shell.run("menu.lua") end
                     return
                end
            elseif event == "disk" or event == "disk_eject" then
                -- Refresh cards
                detectedCards = creditsAPI.findCards()
                attractTimer = os.startTimer(attractDelay)
                term.setCursorPos(1, h/2 + 4)
                term.clearLine()
                local msg = "Players: "
                for i, c in ipairs(detectedCards) do
                    msg = msg .. c.name .. " "
                end
                drawCenter(h/2 + 4, msg, colors.yellow, colors.black)
            end
            
            -- Initial scan
             if #detectedCards == 0 then
                 detectedCards = creditsAPI.findCards()
                 if #detectedCards > 0 then
                    attractTimer = os.startTimer(attractDelay)
                    term.setCursorPos(1, h/2 + 4)
                    term.clearLine()
                    local msg = "Players: "
                    for i, c in ipairs(detectedCards) do
                        msg = msg .. c.name .. " "
                    end
                    drawCenter(h/2 + 4, msg, colors.yellow, colors.black)
                end
            end
        end
        
        local players = {}
        for i, card in ipairs(detectedCards) do
            if i > 3 then break end
            creditsAPI.lock(card.path)
            table.insert(players, {
                bet=1, 
                name=card.name,
                mountPath=card.path 
            })
        end
        
        -- Game Loop
        local msg = "Welcome!"
        while true do
            local allQuit = false
            
            for i, p in ipairs(players) do
                while true do
                    drawMachine(p.bet, p.name .. ": " .. msg, p.name, creditsAPI.get(p.mountPath))
                    local action = waitKey()
                    
                    if action == "LEFT" then
                        p.bet = (p.bet % 3) + 1
                        audio.playChip()
                        msg = "Bet changed"
                    elseif action == "CENTER" then
                        msg = spin(p)
                        break -- Turn done
                    elseif action == "RIGHT" then
                        -- Player leaving?
                        allQuit = true
                        break
                    end
                end
                if allQuit then break end
            end
            
            if allQuit then break end
        end
        
        -- Unlock cards
        for _, p in ipairs(players) do
            creditsAPI.unlock(p.mountPath)
        end
    end
end

main()

]])

writeFile('startup.lua', [[
-- startup.lua
-- Launches the Arcade Menu OS

-- Monitor Detection
local monitor = peripheral.find("monitor")
if monitor then
    term.redirect(monitor)
    
    -- Dynamic Scaling: Find largest text scale that fits the UI
    local min_w, min_h = 39, 19 -- Minimum resolution for Arcade apps
    
    for scale = 5, 0.5, -0.5 do
        monitor.setTextScale(scale)
        local w, h = monitor.getSize()
        if w >= min_w and h >= min_h then
            break
        end
    end
end

term.clear()
term.setCursorPos(1, 1)
print("Booting ArcadeOS...")

if not fs.exists(".button_config") then
    shell.run("config.lua")
end

-- Kiosk Mode: Dedicated public machine (e.g., spawn Can't Stop)
local function readArcadeConfig()
    if not fs.exists(".arcade_config") then return nil end
    local f = fs.open(".arcade_config", "r")
    if not f then return nil end
    local cmd = (f.readAll() or "")
    f.close()
    cmd = cmd:gsub("%s+", "")
    if cmd == "" then return nil end
    return cmd
end

local function adminKeyPresent()
    for _, side in ipairs(peripheral.getNames()) do
        if peripheral.getType(side) == "drive" then
            local path = disk.getMountPath(side)
            if path and fs.exists(path .. "/admin.key") then
                return true
            end
        end
    end
    return false
end

local function shouldKiosk()
    -- If explicitly enabled, always kiosk.
    if fs.exists(".kiosk_mode") then return true end
    -- Default: any configured machine is kiosk unless an admin key disk is inserted.
    if fs.exists(".arcade_config") and not adminKeyPresent() then return true end
    return false
end

-- Remote Update Function
local function runRemoteUpdate()
    term.clear()
    term.setCursorPos(1, 1)
    term.setTextColor(colors.yellow)
    print("ARCADE OS UPDATER")
    print("=================")
    term.setTextColor(colors.white)
    
    -- Read update URL from .update_url or use default
    local DEFAULT_URL = "https://raw.githubusercontent.com/Arcadesys/cc-arcade/main/install.lua"
    local url = DEFAULT_URL
    if fs.exists(".update_url") then
        local f = fs.open(".update_url", "r")
        if f then
            local custom = (f.readAll() or ""):gsub("%s+", "")
            f.close()
            if custom ~= "" then url = custom end
        end
    end
    
    if not http then
        term.setTextColor(colors.red)
        print("")
        print("ERROR: HTTP is disabled!")
        print("Enable HTTP in ComputerCraft config.")
        print("")
        print("Press any key to continue boot...")
        os.pullEvent("key")
        return false
    end
    
    print("")
    print("Downloading from:")
    term.setTextColor(colors.gray)
    print(url:sub(1, 45) .. (url:len() > 45 and "..." or ""))
    term.setTextColor(colors.white)
    print("")
    
    local response, err = http.get(url)
    if not response then
        term.setTextColor(colors.red)
        print("Download failed: " .. tostring(err))
        print("")
        print("Press any key to continue boot...")
        os.pullEvent("key")
        return false
    end
    
    local content = response.readAll()
    response.close()
    
    if not content or #content < 100 then
        term.setTextColor(colors.red)
        print("Invalid response (too short)")
        print("")
        print("Press any key to continue boot...")
        os.pullEvent("key")
        return false
    end
    
    -- Backup and write
    if fs.exists("install.lua") then
        if fs.exists("install.lua.bak") then fs.delete("install.lua.bak") end
        fs.copy("install.lua", "install.lua.bak")
    end
    
    local f = fs.open("install.lua", "w")
    f.write(content)
    f.close()
    
    term.setTextColor(colors.lime)
    print("Download complete!")
    print("Running installer...")
    sleep(1)
    
    shell.run("install.lua")
    return true
end

if shouldKiosk() and fs.exists("kiosk.lua") then
    _G.ARCADE_KIOSK = true
    shell.run("kiosk.lua")
    os.reboot()
end

print("Press 'D' Dev Mode, 'U' Update (2s)...")

_G.ARCADE_DEV_MODE = false
local timer = os.startTimer(2)
while true do
    local event, p1 = os.pullEvent()
    if event == "timer" and p1 == timer then
        break
    elseif event == "char" and p1:lower() == "d" then
        _G.ARCADE_DEV_MODE = true
        print("DEV MODE ENABLED: Infinite Credits")
        sleep(1)
        break
    elseif event == "char" and p1:lower() == "u" then
        runRemoteUpdate()
        -- After update, installer reboots, so we won't reach here
        -- But if update fails, continue boot
        break
    end
end

if not _G.ARCADE_DEV_MODE then
    print("Production Mode: Standard Credits")
end
sleep(0.5)

if fs.exists(".arcade_config") then
    local file = fs.open(".arcade_config", "r")
    local cmd = file.readAll()
    file.close()
    
    -- Trim whitespace just in case
    cmd = cmd:gsub("%s+", "")
    
    if fs.exists(cmd .. ".lua") then
        print("Launching " .. cmd .. "...")
        sleep(0.5)
        shell.run(cmd)
    else
        print("Error: Configured game '" .. cmd .. "' not found!")
        print("Delete .arcade_config to reset.")
    end
elseif fs.exists("setup.lua") then
    shell.run("setup.lua")
else
    print("Error: setup.lua not found!")
end

]])

writeFile('update.lua', [[
-- update.lua
-- Arcade OS Updater
-- Downloads and installs the latest version from the configured URL

local w, h = term.getSize()

-- ============================================================================
-- CONFIGURATION
-- Default update URL points to the official Arcadesys/cc-arcade repo.
-- Override by creating .update_url file with a custom URL.
-- ============================================================================
local UPDATE_URL = "https://raw.githubusercontent.com/Arcadesys/cc-arcade/main/install.lua"

local function centerText(y, text, fg, bg)
    term.setBackgroundColor(bg or colors.black)
    term.setTextColor(fg or colors.white)
    local x = math.floor((w - #text) / 2) + 1
    term.setCursorPos(x, y)
    term.write(text)
end

local function drawHeader()
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.yellow)
    term.setCursorPos(1, 1)
    term.clearLine()
    centerText(1, "ARCADE OS UPDATER", colors.yellow, colors.blue)
end

local function readUpdateUrl()
    if UPDATE_URL then return UPDATE_URL end
    if fs.exists(".update_url") then
        local f = fs.open(".update_url", "r")
        if f then
            local url = f.readAll()
            f.close()
            url = (url or ""):gsub("%s+", "")
            if url ~= "" then return url end
        end
    end
    return nil
end

local function saveUpdateUrl(url)
    local f = fs.open(".update_url", "w")
    if f then
        f.write(url)
        f.close()
    end
end

local function promptForUrl()
    term.setBackgroundColor(colors.black)
    term.clear()
    drawHeader()
    
    centerText(4, "No update URL configured.", colors.yellow, colors.black)
    centerText(6, "Enter the URL to your install.lua:", colors.white, colors.black)
    centerText(7, "(GitHub raw, Pastebin raw, or custom)", colors.gray, colors.black)
    
    term.setCursorPos(2, 9)
    term.setTextColor(colors.lime)
    term.write("> ")
    term.setTextColor(colors.white)
    
    local url = read()
    if url and url:match("^https?://") then
        saveUpdateUrl(url)
        return url
    end
    return nil
end

local function downloadInstaller(url)
    term.setBackgroundColor(colors.black)
    term.clear()
    drawHeader()
    
    centerText(5, "Downloading update...", colors.yellow, colors.black)
    centerText(7, url:sub(1, w - 4), colors.gray, colors.black)
    
    -- Check if HTTP is enabled
    if not http then
        centerText(10, "ERROR: HTTP is disabled!", colors.red, colors.black)
        centerText(12, "Enable HTTP in ComputerCraft config", colors.white, colors.black)
        centerText(13, "or server settings.", colors.white, colors.black)
        sleep(3)
        return nil
    end
    
    local response, err = http.get(url)
    if not response then
        centerText(10, "ERROR: Download failed!", colors.red, colors.black)
        centerText(12, tostring(err or "Unknown error"), colors.gray, colors.black)
        sleep(3)
        return nil
    end
    
    local content = response.readAll()
    response.close()
    
    if not content or #content < 100 then
        centerText(10, "ERROR: Invalid response!", colors.red, colors.black)
        sleep(3)
        return nil
    end
    
    return content
end

local function installUpdate(content)
    term.setBackgroundColor(colors.black)
    term.clear()
    drawHeader()
    
    centerText(5, "Installing update...", colors.yellow, colors.black)
    
    -- Backup current install.lua
    if fs.exists("install.lua") then
        if fs.exists("install.lua.bak") then
            fs.delete("install.lua.bak")
        end
        fs.copy("install.lua", "install.lua.bak")
    end
    
    -- Write new installer
    local f = fs.open("install.lua", "w")
    if not f then
        centerText(8, "ERROR: Could not write file!", colors.red, colors.black)
        sleep(3)
        return false
    end
    f.write(content)
    f.close()
    
    centerText(7, "Running installer...", colors.lime, colors.black)
    sleep(1)
    
    -- Run the installer
    shell.run("install.lua")
    return true
end

local function showMenu()
    local url = readUpdateUrl()
    
    term.setBackgroundColor(colors.black)
    term.clear()
    drawHeader()
    
    centerText(4, "ARCADE OS UPDATE UTILITY", colors.lime, colors.black)
    
    if url then
        centerText(6, "Update URL:", colors.white, colors.black)
        local displayUrl = #url > w - 6 and url:sub(1, w - 9) .. "..." or url
        centerText(7, displayUrl, colors.gray, colors.black)
    else
        centerText(6, "No update URL configured", colors.yellow, colors.black)
    end
    
    centerText(10, "[1] Check for Updates", colors.white, colors.black)
    centerText(11, "[2] Configure Update URL", colors.white, colors.black)
    centerText(12, "[3] Re-run Local Installer", colors.white, colors.black)
    centerText(13, "[4] Exit", colors.white, colors.black)
    
    centerText(h - 1, "Press a key...", colors.gray, colors.black)
    
    while true do
        local _, key = os.pullEvent("char")
        if key == "1" then
            if not url then
                url = promptForUrl()
            end
            if url then
                local content = downloadInstaller(url)
                if content then
                    installUpdate(content)
                    return
                end
            else
                centerText(h - 3, "No URL configured!", colors.red, colors.black)
                sleep(2)
            end
            return showMenu()
        elseif key == "2" then
            url = promptForUrl()
            return showMenu()
        elseif key == "3" then
            if fs.exists("install.lua") then
                term.setBackgroundColor(colors.black)
                term.clear()
                shell.run("install.lua")
            else
                centerText(h - 3, "No local installer found!", colors.red, colors.black)
                sleep(2)
                return showMenu()
            end
            return
        elseif key == "4" or key == "q" then
            term.setBackgroundColor(colors.black)
            term.clear()
            return
        end
    end
end

-- Run the menu
showMenu()

]])


-- Optional: set default game for this machine
local input = require('input')

local function readExistingArcadeConfig()
    if not fs.exists('.arcade_config') then return nil end
    local f = fs.open('.arcade_config', 'r')
    if not f then return nil end
    local cmd = (f.readAll() or '')
    f.close()
    cmd = cmd:gsub('%s+', '')
    if cmd == '' then return nil end
    return cmd
end

local function writeArcadeConfig(cmd)
    local f = fs.open('.arcade_config', 'w')
    f.write(cmd)
    f.close()
end

local function deleteArcadeConfig()
    if fs.exists('.arcade_config') then fs.delete('.arcade_config') end
end

local function configureDefaultGame()
    local options = {
        { name = 'Arcade Menu', cmd = 'menu' },
        { name = "Can't Stop (Free)", cmd = 'cant_stop' },
        { name = 'Horse Race', cmd = 'race' },
        { name = 'Super Slots', cmd = 'slots' },
        { name = 'Blackjack', cmd = 'blackjack' },
        { name = 'Baccarat', cmd = 'baccarat' },
        { name = 'RPS Rogue', cmd = 'rps_rogue' },
        { name = 'Roulette Watch', cmd = 'screensavers/roulette' },
        { name = 'Exchange', cmd = 'exchange' },
        { name = 'Cashier System', cmd = 'cashier' },
        { name = 'Update Arcade', cmd = 'update' },
        { name = 'Keep Current / Skip', cmd = nil }
    }

    local selected = 1
    local existing = readExistingArcadeConfig()

    -- Find existing option index
    for i, opt in ipairs(options) do
        if opt.cmd == existing then
            selected = i
            break
        end
    end

    local w, h = term.getSize()

    local function drawMenu()
        term.setBackgroundColor(colors.black)
        term.clear()
        term.setTextColor(colors.yellow)
        term.setCursorPos(1, 1)
        print('DEFAULT GAME CONFIG')
        term.setTextColor(colors.gray)
        print('Current: ' .. tostring(existing or '<none>'))
        print('')
        term.setTextColor(colors.white)
        print('[L] Up  [C] Select  [R] Down')
        print('')

        for i, opt in ipairs(options) do
            term.setCursorPos(1, 5 + i)
            if i == selected then
                term.setTextColor(colors.lime)
                term.write('> ' .. opt.name)
            else
                term.setTextColor(colors.white)
                term.write('  ' .. opt.name)
            end
        end

        term.setTextColor(colors.gray)
        term.setCursorPos(1, h)
        term.write('Kiosk mode active unless admin.key disk inserted')
    end

    drawMenu()

    while true do
        local event, p1 = os.pullEvent()
        local button = input.getButton(event, p1)

        if button == 'LEFT' then
            selected = selected - 1
            if selected < 1 then selected = #options end
            drawMenu()
        elseif button == 'RIGHT' then
            selected = selected + 1
            if selected > #options then selected = 1 end
            drawMenu()
        elseif button == 'CENTER' then
            local choice = options[selected]
            if choice.cmd == nil then
                -- Keep current / skip
                return
            end
            writeArcadeConfig(choice.cmd)
            term.setTextColor(colors.lime)
            print('')
            print('Set default to: ' .. choice.cmd)
            sleep(1)
            return
        end

        -- Also allow keyboard for convenience
        if event == 'key' then
            local name = keys.getName(p1)
            if name == 'up' then
                selected = selected - 1
                if selected < 1 then selected = #options end
                drawMenu()
            elseif name == 'down' then
                selected = selected + 1
                if selected > #options then selected = 1 end
                drawMenu()
            elseif name == 'enter' then
                local choice = options[selected]
                if choice.cmd == nil then
                    return
                end
                writeArcadeConfig(choice.cmd)
                term.setTextColor(colors.lime)
                print('')
                print('Set default to: ' .. choice.cmd)
                sleep(1)
                return
            end
        end
    end
end

print('Installation Complete!')
sleep(1)
configureDefaultGame()
print('')
print('Rebooting in 2 seconds...')
sleep(2)
os.reboot()