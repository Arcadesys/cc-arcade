-- Arcade OS Installer
-- Generated by bundle.ps1

local function writeFile(path, content)
    local file = fs.open(path, 'w')
    file.write(content)
    file.close()
    print('Installed: ' .. path)
end

print('Installing Arcade OS...')

writeFile('audio.lua', [[
-- audio.lua
-- Simple Audio Manager for Arcade Games
-- Provides DOS-esque sound effects using the Speaker peripheral

local audio = {}
local speaker = peripheral.find("speaker")

-- Helper to play a note safely
local function play(instrument, volume, pitch)
    if speaker then
        speaker.playNote(instrument, volume, pitch)
    end
end

-- Sound Effects

function audio.playClick()
    -- Simple UI click
    play("hat", 0.5, 24)
end

function audio.playConfirm()
    -- Selection confirmation
    play("bit", 1, 14)
end

function audio.playWin()
    -- Victory jingle
    if not speaker then return end
    play("bit", 2, 12)
    sleep(0.1)
    play("bit", 2, 16)
    sleep(0.1)
    play("bit", 2, 19)
    sleep(0.1)
    play("bit", 2, 24)
end

function audio.playLose()
    -- Losing sound
    if not speaker then return end
    play("bit", 2, 12)
    sleep(0.15)
    play("bit", 2, 8)
    sleep(0.15)
    play("bit", 2, 4)
end

function audio.playShuffle()
    -- Card shuffling / Slot spinning tick
    play("snare", 0.5, 24)
end

function audio.playDeal()
    -- Card dealing sound
    play("hat", 1, 16)
end

function audio.playSlotStop()
    -- Slot reel stopping
    play("basedrum", 2, 16)
end

function audio.playChip()
    -- Chip betting sound
    play("hat", 1, 12)
end

function audio.playCashRegister()
    -- Cha-ching!
    if not speaker then return end
    play("bell", 2, 12)
    sleep(0.1)
    play("bell", 2, 16)
end

function audio.playCoinDispense()
    -- Clinking coins
    if not speaker then return end
    for i = 1, 3 do
        play("bit", 1, 20 + math.random(-2, 2))
        sleep(0.05)
    end
end

function audio.playError()
    -- Error buzzer
    if not speaker then return end
    play("bass", 2, 6)
    sleep(0.1)
    play("bass", 2, 6)
end

return audio

]])

writeFile('blackjack.lua', [[
-- blackjack.lua
-- Sequential Multiplayer Blackjack for Arcade OS
-- Visual Overhaul

local w, h = term.getSize()
local SUITS = {"H", "D", "C", "S"}
local RANKS = {"2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"}

-- Colors
local C_TABLE = colors.green
local C_TEXT = colors.white
local C_CARD_BG = colors.white
local C_CARD_RED = colors.red
local C_CARD_BLK = colors.black
local C_HIDDEN = colors.red
local C_LABEL = colors.yellow
local C_MSG = colors.cyan

-- Card Dimensions
local CARD_W = 4
local CARD_H = 3

local input = require("input")

local function waitKey()
    while true do
        local e, p1 = os.pullEvent()
        local button = input.getButton(e, p1)
        if button then
            if e == "redstone" then sleep(0.2) end
            return button
        end
    end
end

--------------------------------------------------------------------------------
-- GAME LOGIC
--------------------------------------------------------------------------------

local function createDeck()
    local deck = {}
    for _, s in ipairs(SUITS) do
        for _, r in ipairs(RANKS) do
            table.insert(deck, {suit=s, rank=r})
        end
    end
    -- Shuffle
    for i = #deck, 2, -1 do
        local j = math.random(i)
        deck[i], deck[j] = deck[j], deck[i]
    end
    return deck
end

local function getCardValue(card)
    if card.rank == "A" then return 11 end
    if card.rank == "K" or card.rank == "Q" or card.rank == "J" then return 10 end
    return tonumber(card.rank)
end

local function calculateHand(hand)
    local total = 0
    local aces = 0
    for _, card in ipairs(hand) do
        total = total + getCardValue(card)
        if card.rank == "A" then aces = aces + 1 end
    end
    while total > 21 and aces > 0 do
        total = total - 10
        aces = aces - 1
    end
    return total
end

local function drawCardDeck(deck)
    if #deck == 0 then deck = createDeck() end -- Reshuffle if empty
    return table.remove(deck, 1)
end

--------------------------------------------------------------------------------
-- UI
--------------------------------------------------------------------------------



local function animateSparkles(x, y, width, height)
    local duration = 1.5
    local startTime = os.clock()
    local colorsList = {colors.yellow, colors.gold or colors.orange, colors.white}
    
    while os.clock() - startTime < duration do
        local rx = math.random(x, x + width - 1)
        local ry = math.random(y, y + height - 1)
        local color = colorsList[math.random(1, #colorsList)]
        
        term.setCursorPos(rx, ry)
        term.setTextColor(color)
        term.write("*")
        
        sleep(0.05)
    end
end

local function animateChips(startX, startY, endX, endY)
    local steps = 10
    local dx = (endX - startX) / steps
    local dy = (endY - startY) / steps
    
    for i = 1, steps do
        local cx = math.floor(startX + dx * i)
        local cy = math.floor(startY + dy * i)
        
        -- Draw Chip
        term.setCursorPos(cx, cy)
        term.setBackgroundColor(colors.yellow)
        term.setTextColor(colors.black)
        term.write("O")
        
        sleep(0.05)
        
        -- Clear Chip (simple clear, might overwrite background)
        term.setCursorPos(cx, cy)
        term.setBackgroundColor(colors.green) -- Assuming table color
        term.write(" ")
    end
end

local function drawText(x, y, text, fg, bg)
    term.setCursorPos(x, y)
    if fg then term.setTextColor(fg) end
    if bg then term.setBackgroundColor(bg) end
    term.write(text)
end

local function drawCenter(y, text, fg, bg)
    local x = math.floor((w - #text)/2) + 1
    drawText(x, y, text, fg, bg)
end

local function getSuitColor(suit)
    if suit == "H" or suit == "D" then return C_CARD_RED else return C_CARD_BLK end
end

local function getSuitChar(suit)
    -- If using a font that supports symbols, we could use them.
    -- Standard CC font doesn't have suit symbols, so we use letters.
    return suit
end

local function drawGraphicalCard(x, y, card, hidden)
    -- Card Background
    term.setBackgroundColor(hidden and C_HIDDEN or C_CARD_BG)
    
    for i=0, CARD_H-1 do
        term.setCursorPos(x, y+i)
        term.write(string.rep(" ", CARD_W))
    end
    
    if hidden then
        -- Pattern for hidden card
        term.setTextColor(colors.white)
        term.setCursorPos(x, y+1)
        term.write(" ?? ")
    else
        -- Rank and Suit
        local sColor = getSuitColor(card.suit)
        term.setTextColor(sColor)
        
        local rankStr = card.rank
        if #rankStr == 1 then rankStr = rankStr .. " " end
        
        -- Top Left
        term.setCursorPos(x, y)
        term.write(rankStr)
        
        -- Center Suit
        term.setCursorPos(x+1, y+1)
        term.write(getSuitChar(card.suit))
        
        -- Bottom Right (Rotated/Inverted conceptually, but just text here)
        term.setCursorPos(x+CARD_W-#rankStr, y+CARD_H-1)
        term.write(rankStr)
    end
end

local function drawHandGraphical(centerX, y, name, hand, hideFirst, isActive, status)
    -- Calculate total width of hand to center it
    -- Overlap cards by 1 column if hand is large?
    -- Let's do simple spacing: CARD_W + 1
    local spacing = CARD_W + 1
    local totalW = (#hand * spacing) - 1
    local startX = math.floor(centerX - totalW/2)
    
    -- Draw Name Label
    local labelColor = isActive and colors.yellow or colors.lightGray
    drawText(startX, y - 1, name, labelColor, C_TABLE)
    
    -- Draw Status if present
    if status and status ~= "Playing" then
        local sColor = colors.lightGray
        if status == "Blackjack!" or string.find(status, "WIN") then sColor = colors.gold or colors.orange end
        if status == "Bust!" or string.find(status, "LOSE") then sColor = colors.red end
        drawText(startX + #name + 2, y - 1, status, sColor, C_TABLE)
    end
    
    -- Draw Cards
    for i, card in ipairs(hand) do
        local cx = startX + (i-1)*spacing
        local isHidden = hideFirst and (i == 1)
        drawGraphicalCard(cx, y, card, isHidden)
    end
    
    -- Draw Score
    if not hideFirst then
        local score = calculateHand(hand)
        drawText(startX, y + CARD_H, "Score: " .. score, colors.gray, C_TABLE)
    end
end

local function drawTable(players, dealerHand, currentPlayerIdx, message, showDealer)
    term.setBackgroundColor(C_TABLE)
    term.clear()
    
    -- Header
    drawCenter(1, " BLACKJACK ", colors.black, colors.lime)
    
    -- Dealer Area (Top Center)
    local dealerY = 3
    drawHandGraphical(w/2, dealerY, "DEALER", dealerHand, not showDealer, false, nil)
    
    -- Player Area (Bottom)
    -- Distribute players evenly
    local playerY = h - 6 -- Leave room for controls
    local sectionW = w / #players
    
    for i, p in ipairs(players) do
        local pCenterX = (i-1)*sectionW + sectionW/2
        local isActive = (i == currentPlayerIdx)
        -- Add indicator if active
        if isActive then
            drawText(math.floor(pCenterX)-2, playerY-2, " vvv ", colors.white, C_TABLE)
        end
        drawHandGraphical(pCenterX, playerY, "P"..i, p.hand, false, isActive, p.status)
    end
    
    -- Message / Controls Area (Bottom 2 lines)
    local footerY = h - 1
    term.setBackgroundColor(colors.black)
    term.setCursorPos(1, h-1)
    term.clearLine()
    term.setCursorPos(1, h)
    term.clearLine()
    
    if message then
        drawCenter(h-1, message, C_MSG, colors.black)
    end
    
    -- Draw 3-Column Footer
    local colW = math.floor(w / 3)
    local c1 = "Hit"
    local c2 = "Stand"
    local c3 = "Shift >"
    
    if currentPlayerIdx == 0 then
        c1 = "-"
        c2 = "Deal"
        c3 = "Cash Out"
    elseif message and string.find(message, "ADV") then
        c1 = "Double"
        c2 = "Surrender"
        c3 = "Back"
    end
    
    -- Left Button
    term.setCursorPos(1, h)
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", colW))
    drawText(math.floor(colW/2 - #c1/2)+1, h, c1, colors.white, colors.red)
    
    -- Center Button
    term.setCursorPos(colW + 1, h)
    term.setBackgroundColor(colors.yellow)
    term.setTextColor(colors.black)
    term.write(string.rep(" ", colW))
    drawText(colW + math.floor(colW/2 - #c2/2)+1, h, c2, colors.black, colors.yellow)
    
    -- Right Button
    term.setCursorPos(colW * 2 + 1, h)
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", w - (colW*2)))
    drawText(colW*2 + math.floor((w - colW*2)/2 - #c3/2)+1, h, c3, colors.white, colors.blue)
end

--------------------------------------------------------------------------------
-- MAIN LOOP
--------------------------------------------------------------------------------

local function main()
    term.setBackgroundColor(colors.black)
    term.clear()
    
    local creditsAPI = require("credits")
    local audio = require("audio")
    
    while true do
        drawCenter(h/2 - 2, "BLACKJACK", colors.lime, colors.black)
        drawCenter(h/2, "Insert Cards (Max 3)", colors.white, colors.black)
        drawCenter(h/2 + 2, "[C] Start Game   [R] Exit", colors.gray, colors.black)
        
        -- Lobby Loop
        local detectedCards = {}
        while true do
            local event, p1 = os.pullEvent()
            if event == "key" then
                local key = keys.getName(p1)
                if key == "enter" or key == "space" then -- Start
                    if #detectedCards > 0 then break end
                    drawCenter(h/2 + 4, "No players detected!", colors.red, colors.black)
                    sleep(1)
                    term.setCursorPos(1, h/2+4) term.clearLine()
                elseif key == "backspace" or key == "e" then -- Exit
                     term.setBackgroundColor(colors.black)
                     term.clear()
                     if fs.exists("menu.lua") then shell.run("menu.lua") end
                     return
                end
            elseif event == "disk" or event == "disk_eject" then
                -- Refresh cards
                detectedCards = creditsAPI.findCards()
                term.setCursorPos(1, h/2 + 4)
                term.clearLine()
                local msg = "Players: "
                for i, c in ipairs(detectedCards) do
                    msg = msg .. c.name .. " "
                end
                drawCenter(h/2 + 4, msg, colors.yellow, colors.black)
            end
            
            -- Initial scan if just opened
            if #detectedCards == 0 then
                 detectedCards = creditsAPI.findCards()
                 if #detectedCards > 0 then
                    term.setCursorPos(1, h/2 + 4)
                    term.clearLine()
                    local msg = "Players: "
                    for i, c in ipairs(detectedCards) do
                        msg = msg .. c.name .. " "
                    end
                    drawCenter(h/2 + 4, msg, colors.yellow, colors.black)
                end
            end
        end
        
        -- Limit to 3 players
        local players = {}
        for i, card in ipairs(detectedCards) do
            if i > 3 then break end
            creditsAPI.lock(card.path)
            table.insert(players, {
                hand={}, 
                status="Playing", 
                bet=10, 
                name=card.name, -- Use card name
                mountPath=card.path 
            })
            if creditsAPI.get(card.path) < 10 then
                drawCenter(h/2, card.name .. " needs 10 credits!", colors.red, colors.black)
                creditsAPI.unlock(card.path)
                sleep(2)
                return -- Go back to lobby effectively (restarts main)
            end
            creditsAPI.remove(10, card.path) -- Deduct bet immediately
        end
        
        local deck = createDeck()
        local dealerHand = {}
        
        -- Initial Deal
        for _=1,2 do
            for _, p in ipairs(players) do 
                table.insert(p.hand, drawCardDeck(deck)) 
                audio.playDeal()
                sleep(0.2)
            end
            table.insert(dealerHand, drawCardDeck(deck))
            audio.playDeal()
            sleep(0.2)
        end
        
        -- Player Turns
        for i, p in ipairs(players) do
            while true do
                local score = calculateHand(p.hand)
                if score == 21 and #p.hand == 2 then
                    p.status = "Blackjack!"
                    break
                elseif score > 21 then
                    p.status = "Bust!"
                    break
                end
                
                drawTable(players, dealerHand, i, p.name .. "'s Turn", false)
                local action = waitKey()
                
                -- Normal Mode
                if action == "LEFT" then -- Hit
                    table.insert(p.hand, drawCardDeck(deck))
                    audio.playDeal()
                elseif action == "CENTER" then -- Stand
                    p.status = "Stand"
                    break
                elseif action == "RIGHT" then -- Shift (Advanced Mode)
                    -- Show Advanced Options
                    drawTable(players, dealerHand, i, "ADV: [L] Dbl [C] Surr [R] Back", false)
                    local advAction = waitKey()
                    
                    if advAction == "LEFT" then -- Double Down
                        if creditsAPI.get(p.mountPath) >= p.bet then
                            creditsAPI.remove(p.bet, p.mountPath)
                            p.bet = p.bet * 2
                            table.insert(p.hand, drawCardDeck(deck))
                            audio.playDeal()
                            score = calculateHand(p.hand)
                            if score > 21 then p.status = "Bust!" else p.status = "Dbl Stand" end
                            break
                        else
                             drawTable(players, dealerHand, i, "Not enough credits!", false)
                             sleep(1)
                        end
                    elseif advAction == "CENTER" then -- Surrender
                         p.status = "Surrender"
                         break
                    elseif advAction == "RIGHT" then -- Back
                        -- Loop continues
                    end
                end
            end
            drawTable(players, dealerHand, i, p.name .. " Done", false)
            sleep(0.5)
        end
        
        -- Dealer Turn
        drawTable(players, dealerHand, 0, "Dealer's Turn...", true)
        sleep(1)
        while calculateHand(dealerHand) < 17 do
            table.insert(dealerHand, drawCardDeck(deck))
            audio.playDeal()
            drawTable(players, dealerHand, 0, "Dealer Hits...", true)
            sleep(1)
        end
        
        -- Resolve
        local dealerScore = calculateHand(dealerHand)
        local dealerBust = dealerScore > 21
        
        for _, p in ipairs(players) do
            local pScore = calculateHand(p.hand)
            if p.status == "Bust!" then
                p.status = "LOSE"
            elseif p.status == "Surrender" then
                p.status = "SURRENDER"
                creditsAPI.add(math.floor(p.bet / 2), p.mountPath)
            elseif p.status == "Blackjack!" then
                 p.status = "WIN!"
                 creditsAPI.add(math.floor(p.bet * 2.5), p.mountPath) -- 3:2 payout usually, but let's do 2.5x return
            elseif dealerBust then
                p.status = "WIN!"
                creditsAPI.add(p.bet * 2, p.mountPath)
            elseif pScore > dealerScore then
                p.status = "WIN!"
                creditsAPI.add(p.bet * 2, p.mountPath)
            elseif pScore == dealerScore then
                p.status = "PUSH"
                creditsAPI.add(p.bet, p.mountPath)
            else
                p.status = "LOSE"
            end
            
            -- Unlock card
            creditsAPI.unlock(p.mountPath)
        end
        
        drawTable(players, dealerHand, 0, "Round Over!", true)
        
        -- Play Animations for Winners
        local sectionW = w / #players
        local playerY = h - 6
        local dealerX, dealerY = w/2, 3
        
        for i, p in ipairs(players) do
            if p.status == "WIN!" or p.status == "Blackjack!" then
                local pCenterX = math.floor((i-1)*sectionW + sectionW/2)
                
                -- Animate Chips from Dealer to Player
                audio.playChip()
                animateChips(dealerX, dealerY, pCenterX, playerY)
                audio.playWin()
                
                -- Animate Sparkles around Player
                animateSparkles(pCenterX - 6, playerY - 2, 12, 6)
                
                drawTable(players, dealerHand, 0, "Round Over!", true) -- Redraw to clear noise
            end
        end
        
        drawTable(players, dealerHand, 0, "Round Over! [C] Play Again", true)
        
        local endAction = waitKey()
        if endAction == "RIGHT" then
            break
        end
    end
    
    -- Exit to Menu
    term.setBackgroundColor(colors.black)
    term.clear()
    if fs.exists("menu.lua") then shell.run("menu.lua") end
end

main()

]])

writeFile('cant_stop.lua', [[
-- cant_stop.lua
-- A push-your-luck dice game for the Arcade OS

local w, h = term.getSize()

-- 3-Button Config
local input = require("input")

local function waitKey()
    while true do
        local e, p1 = os.pullEvent()
        local button = input.getButton(e, p1)
        if button then
            if e == "redstone" then sleep(0.2) end
            return button
        end
    end
end

--------------------------------------------------------------------------------
-- GAME LOGIC
--------------------------------------------------------------------------------

local COL_LENGTHS = {
    [2]=3, [3]=5, [4]=7, [5]=9, [6]=11,
    [7]=13,
    [8]=11, [9]=9, [10]=7, [11]=5, [12]=3
}

local board = {} -- [col] = {p1=0, p2=0, owner=nil}
for i=2,12 do board[i] = {p1=0, p2=0, owner=nil} end

local currentPlayer = 1
local tempMarkers = {} -- [col] = current_step
local runnersUsed = 0
local MAX_RUNNERS = 3

local function rollDice()
    local d = {}
    for i=1,4 do table.insert(d, math.random(1,6)) end
    return d
end

local function getPairings(dice)
    -- 3 ways to pair 4 dice: (1+2, 3+4), (1+3, 2+4), (1+4, 2+3)
    local pairs = {
        { {dice[1], dice[2]}, {dice[3], dice[4]} },
        { {dice[1], dice[3]}, {dice[2], dice[4]} },
        { {dice[1], dice[4]}, {dice[2], dice[3]} }
    }
    -- Calculate sums
    local options = {}
    for _, p in ipairs(pairs) do
        local s1 = p[1][1] + p[1][2]
        local s2 = p[2][1] + p[2][2]
        table.insert(options, {s1, s2})
    end
    return options
end

local function canAdvance(col)
    if board[col].owner then return false end
    if runnersUsed >= MAX_RUNNERS and not tempMarkers[col] then
        -- Check if we have a base marker here? No, runners must be placed.
        -- If we have a base marker but no runner, we need a runner to advance.
        return false
    end
    -- Check if already at top
    local current = tempMarkers[col] or (currentPlayer == 1 and board[col].p1 or board[col].p2)
    if current >= COL_LENGTHS[col] then return false end
    return true
end

local function isValidOption(opt)
    -- An option is valid if at least one of the sums can be played
    return canAdvance(opt[1]) or canAdvance(opt[2])
end

--------------------------------------------------------------------------------
-- UI
--------------------------------------------------------------------------------

local function drawText(x, y, text, fg, bg)
    term.setCursorPos(x, y)
    if fg then term.setTextColor(fg) end
    if bg then term.setBackgroundColor(bg) end
    term.write(text)
end

local function drawFooter(c1, c2, c3)
    local colW = math.floor(w / 3)
    
    -- Left Button
    term.setCursorPos(1, h)
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", colW))
    drawText(math.floor(colW/2 - #c1/2)+1, h, c1, colors.white, colors.red)
    
    -- Center Button
    term.setCursorPos(colW + 1, h)
    term.setBackgroundColor(colors.yellow)
    term.setTextColor(colors.black)
    term.write(string.rep(" ", colW))
    drawText(colW + math.floor(colW/2 - #c2/2)+1, h, c2, colors.black, colors.yellow)
    
    -- Right Button
    term.setCursorPos(colW * 2 + 1, h)
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", w - (colW*2)))
    drawText(colW*2 + math.floor((w - colW*2)/2 - #c3/2)+1, h, c3, colors.white, colors.blue)
end

local function drawBoard(showTemp)
    term.setBackgroundColor(colors.black)
    term.clear()
    
    -- Draw Columns
    local startX = 2
    for col=2,12 do
        local x = startX + (col-2)*3
        local len = COL_LENGTHS[col]
        local owner = board[col].owner
        
        -- Header
        term.setCursorPos(x, 1)
        if owner == 1 then term.setTextColor(colors.blue)
        elseif owner == 2 then term.setTextColor(colors.red)
        else term.setTextColor(colors.white) end
        term.write(tostring(col))
        
        -- Track
        for step=1, len do
            local y = h - 2 - step
            term.setCursorPos(x, y)
            
            local char = "."
            local fg = colors.gray
            
            -- Check markers
            local p1 = board[col].p1
            local p2 = board[col].p2
            local temp = tempMarkers[col]
            
            if showTemp and temp and temp == step then
                char = "X"
                fg = (currentPlayer == 1) and colors.cyan or colors.orange
            elseif p1 == step and p2 == step then
                char = "B" -- Both
                fg = colors.magenta
            elseif p1 == step then
                char = "1"
                fg = colors.blue
            elseif p2 == step then
                char = "2"
                fg = colors.red
            end
            
            term.setTextColor(fg)
            term.write(char)
        end
    end
    
    -- Status
    term.setCursorPos(1, h)
    term.setBackgroundColor(colors.gray)
    term.setTextColor(colors.black)
    term.clearLine()
    term.write(" P" .. currentPlayer .. "'s Turn")
end



local function drawActionMenu()
    term.setCursorPos(1, h-2)
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.white)
    term.clearLine()
    term.write("Action:")
    
    drawFooter("Roll Again", "Stop (Save)", "View Board")
end

--------------------------------------------------------------------------------
-- MAIN LOOP
--------------------------------------------------------------------------------

local creditsAPI = require("credits")
local audio = require("audio")

local function main()
    if creditsAPI.get() < 5 then
        term.clear()
        term.setCursorPos(1, h/2)
        term.setTextColor(colors.red)
        term.write("Insert Coin: 5 Credits")
        sleep(2)
        return
    end
    creditsAPI.remove(5)

    -- Player Selection
    local numPlayers = 1
    while true do
        term.setBackgroundColor(colors.black)
        term.clear()
        drawText(cx - 5, cy - 2, "CANT STOP", colors.lime, colors.black)
        drawText(cx - 8, cy, "Select Players: " .. numPlayers, colors.white, colors.black)
        drawText(cx - 10, cy + 2, "[L] -   [C] Start   [R] +", colors.gray, colors.black)
        
        local key = waitKey()
        if key == "LEFT" and numPlayers > 1 then numPlayers = numPlayers - 1 end
        if key == "RIGHT" and numPlayers < 3 then numPlayers = numPlayers + 1 end
        if key == "CENTER" then break end
    end

    -- Initialize Board for N players
    -- board[col] = { positions = {0, 0, 0}, owner = nil }
    for i=2,12 do 
        board[i] = { positions={}, owner=nil } 
        for p=1, numPlayers do board[i].positions[p] = 0 end
    end

    local currentPlayer = 1
    
    -- Redefine drawBoard to handle N players
    local function drawBoard(showTemp)
        term.setBackgroundColor(colors.black)
        term.clear()
        
        -- Draw Columns
        local startX = 2
        for col=2,12 do
            local x = startX + (col-2)*3
            local len = COL_LENGTHS[col]
            local owner = board[col].owner
            
            -- Header
            term.setCursorPos(x, 1)
            if owner == 1 then term.setTextColor(colors.blue)
            elseif owner == 2 then term.setTextColor(colors.red)
            elseif owner == 3 then term.setTextColor(colors.green)
            else term.setTextColor(colors.white) end
            term.write(tostring(col))
            
            -- Track
            for step=1, len do
                local y = h - 2 - step
                term.setCursorPos(x, y)
                
                local char = "."
                local fg = colors.gray
                
                -- Check markers
                local temp = tempMarkers[col]
                
                if showTemp and temp and temp == step then
                    char = "X"
                    if currentPlayer == 1 then fg = colors.cyan
                    elseif currentPlayer == 2 then fg = colors.orange
                    else fg = colors.lime end
                else
                    -- Check player positions
                    local occupants = {}
                    for p=1, numPlayers do
                        if board[col].positions[p] == step then table.insert(occupants, p) end
                    end
                    
                    if #occupants > 0 then
                        if #occupants > 1 then
                            char = "*" -- Multiple
                            fg = colors.magenta
                        else
                            char = tostring(occupants[1])
                            if occupants[1] == 1 then fg = colors.blue
                            elseif occupants[1] == 2 then fg = colors.red
                            elseif occupants[1] == 3 then fg = colors.green end
                        end
                    end
                end
                
                term.setTextColor(fg)
                term.write(char)
            end
        end
        
        -- Status
        term.setCursorPos(1, h)
        term.setBackgroundColor(colors.gray)
        term.setTextColor(colors.black)
        term.clearLine()
        local pColor = "Blue"
        if currentPlayer == 2 then pColor = "Red" elseif currentPlayer == 3 then pColor = "Green" end
        term.write(" P" .. currentPlayer .. " ("..pColor..") Turn")
    end

    while true do
        -- Turn Start
        tempMarkers = {}
        runnersUsed = 0
        local turnOver = false
        
        while not turnOver do
            -- Roll Dice
            audio.playShuffle()
            local dice = rollDice()
            local options = getPairings(dice)
            
            -- Helper to check advance with new board structure
            local function canAdvance(col)
                if board[col].owner then return false end
                if runnersUsed >= MAX_RUNNERS and not tempMarkers[col] then
                    return false
                end
                local current = tempMarkers[col] or board[col].positions[currentPlayer]
                if current >= COL_LENGTHS[col] then return false end
                return true
            end

            -- Check for Bust (No valid moves at all)
            local canMove = false
            -- Need to redefine isValidOption locally or pass canAdvance
            local function isValidOption(opt)
                return canAdvance(opt[1]) or canAdvance(opt[2])
            end

            for _, opt in ipairs(options) do
                if isValidOption(opt) then canMove = true break end
            end
            
            if not canMove then
                drawBoard(true)
                term.setCursorPos(1, h-2)
                term.setTextColor(colors.red)
                term.write("BUST! No valid moves.")
                audio.playLose()
                sleep(2)
                turnOver = true
            else
                -- Selection Phase (Direct Selection)
                local chosen = nil
                while not chosen do
                    drawBoard(true)
                    
                    -- Draw Options at bottom
                    local y = h - 5
                    term.setCursorPos(1, y)
                    term.setBackgroundColor(colors.black)
                    term.setTextColor(colors.white)
                    term.clearLine()
                    term.write("Choose Pair (1-3):")
                    
                    for i, opt in ipairs(options) do
                        local s1, s2 = opt[1], opt[2]
                        local valid = isValidOption(opt)
                        local str = string.format("[%d] %d & %d", i, s1, s2)
                        if not valid then str = str .. " (X)" end
                        
                        term.setCursorPos(2 + (i-1)*13, y+1)
                        if valid then term.setTextColor(colors.yellow) else term.setTextColor(colors.gray) end
                        term.write(str)
                    end
                    
                    term.setCursorPos(1, h)
                    drawFooter("Opt 1", "Opt 2", "Opt 3")
                    
                    local key = waitKey()
                    local selIdx = 0
                    if key == "LEFT" then selIdx = 1
                    elseif key == "CENTER" then selIdx = 2
                    elseif key == "RIGHT" then selIdx = 3 end
                    
                    if selIdx > 0 and selIdx <= #options then
                        if isValidOption(options[selIdx]) then
                            chosen = options[selIdx]
                        end
                    end
                end
                
                -- Apply Move
                local function advance(col)
                    if not canAdvance(col) then return end
                    if not tempMarkers[col] then
                        -- New runner
                        runnersUsed = runnersUsed + 1
                        local start = board[col].positions[currentPlayer]
                        tempMarkers[col] = start + 1
                    else
                        tempMarkers[col] = tempMarkers[col] + 1
                    end
                end
                
                advance(chosen[1])
                advance(chosen[2])
                audio.playChip()
                
                -- Action Phase (Roll or Stop)
                local actionChosen = false
                while not actionChosen do
                    drawBoard(true)
                    drawActionMenu()
                    
                    local key = waitKey()
                    if key == "LEFT" then -- Roll Again
                        actionChosen = true
                    elseif key == "CENTER" then -- Stop
                        -- Save Progress
                        for col, step in pairs(tempMarkers) do
                            board[col].positions[currentPlayer] = step
                            
                            -- Check Column Win
                            if step >= COL_LENGTHS[col] then
                                board[col].owner = currentPlayer
                                audio.playWin()
                            end
                        end
                        turnOver = true
                        actionChosen = true
                        audio.playConfirm()
                    elseif key == "RIGHT" then
                        -- View Board (Toggle) - Actually just redraws since loop continues
                    end
                end
            end
        end
        
        -- Check Game Win (3 Columns)
        local owned = 0
        for col=2,12 do if board[col].owner == currentPlayer then owned = owned + 1 end end
        if owned >= 3 then
            term.clear()
            term.setCursorPos(1, h/2)
            term.write("PLAYER " .. currentPlayer .. " WINS!")
            audio.playWin()
            sleep(3)
            break
        end
        
        -- Switch Player
        currentPlayer = (currentPlayer % numPlayers) + 1
    end
    
    if fs.exists("menu.lua") then shell.run("menu.lua") end
end

main()

]])

writeFile('cashier.lua', [[
-- cashier.lua
-- Arcade Cashier System
-- Handles Credit Cards (Floppy Disks) and Currency Exchange

local input = require("input")
local credits = require("credits")
local audio = require("audio")

-- === CONFIGURATION ===
local RATES_INPUT = {
    ["minecraft:diamond"] = 1,
    ["minecraft:obsidian"] = 4,
    ["minecraft:ender_eye"] = 16
}

local RATES_OUTPUT = {
    ["minecraft:diamond"] = 1,
    ["minecraft:ender_pearl"] = 16
}

local SCREENSAVER_TIMEOUT = 10 -- Seconds of inactivity before screensaver
local SCREENSAVER_DIR = "screensavers"

-- === PERIPHERALS ===
local drive = peripheral.find("drive")
local bridge = nil -- Deprecated: Replaced by Bank Chest
local monitors = { peripheral.find("monitor") }

-- Find all connected inventories
local function findAllInventories()
    local invs = {}
    for _, name in ipairs(peripheral.getNames()) do
        -- Wrap the peripheral
        local p = peripheral.wrap(name)
        
        -- Check if it's an inventory (has .list and .size)
        -- Also explicitly exclude things we know aren't "storage" chests for our purpose
        -- (like disk drives which technically have inventory space sometimes, or strict exclusions)
        local type = peripheral.getType(p)
        
        -- Exclude common non-chest peripherals
        if type ~= "drive" and type ~= "monitor" and type ~= "speaker" and type ~= "modem" and type ~= "computer" then
            -- Verify it has inventory methods
            if p.list and p.size and p.pushItems and p.pullItems then
                table.insert(invs, p)
            end
        end
    end
    return invs
end

local allInventories = findAllInventories()

local mon = nil
if #monitors > 0 then
    mon = monitors[1]
    mon.setTextScale(1)
    if mon.isColor() then
        term.redirect(mon)
    end
end

local w, h = term.getSize()

-- === STATE MANAGEMENT ===
local lastActivity = os.clock()
local chestConfig = nil -- Will hold { customer = "name", bank = "name" }

local function resetActivity()
    lastActivity = os.clock()
end

local function clear()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.white)
    term.clear()
    term.setCursorPos(1, 1)
end

local function centerText(y, text, color)
    term.setCursorPos(1, y)
    term.clearLine()
    local x = math.floor((w - #text) / 2) + 1
    term.setCursorPos(x, y)
    if color then term.setTextColor(color) end
    term.write(text)
end

-- === CONFIGURATION WIZARD ===
local function configureChests()
    -- Try to load existing config
    if fs.exists(".chest_config") then
        local f = fs.open(".chest_config", "r")
        local data = f.readAll()
        f.close()
        local success, cfg = pcall(textutils.unserialize, data)
        if success and cfg and cfg.customer and cfg.bank then
            -- Verify they still exist
            if peripheral.isPresent(cfg.customer) and peripheral.isPresent(cfg.bank) then
                chestConfig = cfg
                return
            end
        end
    end

    -- Start Wizard
    while true do
        allInventories = findAllInventories()
        
        if #allInventories < 2 then
            clear()
            centerText(h/2-1, "SETUP ERROR", colors.red)
            centerText(h/2+1, "Need 2 Chests Connected", colors.white)
            centerText(h/2+2, "Found: " .. #allInventories, colors.gray)
            sleep(2)
        else
            clear()
            centerText(2, "PAYMENT SETUP", colors.cyan)
            centerText(4, "Found " .. #allInventories .. " Chests/Barrels", colors.white)
            
            centerText(7, "Step 1: EMPTY All Chests", colors.yellow)
            centerText(9, "Step 2: Put 1 DIAMOND in", colors.yellow)
            centerText(10, "the CUSTOMER (Input) Chest", colors.yellow) 
            
            centerText(h-2, "Scanning...", colors.gray)
            
            -- Scan loop
            local customerChestName = nil
            local bankChestName = nil
            
            for _, inv in ipairs(allInventories) do
                local items = inv.list()
                for slot, item in pairs(items) do
                    if item.name == "minecraft:diamond" then
                        customerChestName = peripheral.getName(inv)
                        break
                    end
                end
                if customerChestName then break end
            end
            
            if customerChestName then
                -- Automatically assign the first OTHER chest as Bank
                for _, inv in ipairs(allInventories) do
                    local name = peripheral.getName(inv)
                    if name ~= customerChestName then
                        bankChestName = name
                        break
                    end
                end
                
                if bankChestName then
                   clear()
                   centerText(h/2, "CONFIG SUCCESS!", colors.lime)
                   centerText(h/2+2, "Customer: " .. customerChestName, colors.gray)
                   centerText(h/2+3, "Bank: " .. bankChestName, colors.gray)
                   
                   chestConfig = { customer = customerChestName, bank = bankChestName }
                   
                   local f = fs.open(".chest_config", "w")
                   f.write(textutils.serialize(chestConfig))
                   f.close()
                   
                   centerText(h-2, "Please Remove Diamond", colors.yellow)
                   sleep(3)
                   
                   -- Wait for diamond removal
                   while true do
                        local hasItem = false
                        local inv = peripheral.wrap(customerChestName)
                        for k,v in pairs(inv.list()) do hasItem = true end
                        if not hasItem then break end
                        sleep(0.5)
                   end
                   return
                end
            end
            sleep(1)
        end
    end
end

-- === ANIMATIONS ===

local function animateCountUp(startVal, endVal, y, labelColor, valColor)
    local steps = 10
    local delay = 0.05
    local diff = endVal - startVal
    
    if diff == 0 then return end
    
    for i = 1, steps do
        local current = math.floor(startVal + (diff * (i/steps)))
        centerText(y, "CREDITS: " .. current, valColor or colors.yellow)
        sleep(delay)
    end
end

local function animateScanning(y)
    local frames = {
        "ScAnNiNg...",
        "sCaNnInG...",
        "ScAnNiNg...",
        "sCaNnInG..."
    }
    for _, f in ipairs(frames) do
        centerText(y, f, colors.yellow)
        sleep(0.1)
    end
end

local function animateDispense(y)
    centerText(y, "Dispensing...", colors.yellow)
    audio.playCoinDispense()
    for i=1,3 do
        centerText(y, "Dispensing" .. string.rep(".", i), colors.yellow)
        sleep(0.15)
    end
end

-- === SCREENSAVER ===
local function runScreensaver()
    if not fs.exists(SCREENSAVER_DIR) or not fs.isDir(SCREENSAVER_DIR) then
        return
    end
    
    local files = fs.list(SCREENSAVER_DIR)
    if #files == 0 then return end
    
    local randomFile = files[math.random(1, #files)]
    local fullPath = fs.combine(SCREENSAVER_DIR, randomFile)
    
    local function screensaverRoutine()
        shell.run(fullPath)
    end
    
    local function inputWatcher()
        local ev, p1 = os.pullEvent()
        while true do
            if ev == "key" or ev == "mouse_click" or ev == "monitor_touch" or ev == "disk" then
                return true
            end
            ev, p1 = os.pullEvent()
        end
    end
    
    parallel.waitForAny(screensaverRoutine, inputWatcher)
    
    resetActivity()
    clear()
end

-- === LOGIC ===

local function scanIOChest()
    if not chestConfig then return 0, {} end
    local cust = peripheral.wrap(chestConfig.customer)
    if not cust then return 0, {} end
    
    local total = 0
    local items = {}
    
    for slot, item in pairs(cust.list()) do
        local rate = RATES_INPUT[item.name]
        if rate then
            local val = rate * item.count
            total = total + val
            table.insert(items, {slot=slot, name=item.name, count=item.count, value=val})
        else
             -- Also track invalid items to move them to bank (garbage collection)
             table.insert(items, {slot=slot, name=item.name, count=item.count, value=0, garbage=true})
        end
    end
    return total, items
end

local function safeTransfer(fromObj, fromName, toObj, toName, fromSlot, count)
    -- Attempt 1: Push from Source
    local success1, res1 = pcall(function()
        return fromObj.pushItems(toName, fromSlot, count)
    end)
    
    if success1 and type(res1) == "number" and res1 >= count then return res1 end
    
    -- Attempt 2: Pull from Destination
    local success2, res2 = pcall(function()
        return toObj.pullItems(fromName, fromSlot, count)
    end)
    
    if success2 and type(res2) == "number" then return res2 end
    
    -- Return error info
    local err = "Transfer Failed."
    if not success1 then err = err .. " Push: " .. tostring(res1) end
    if not success2 then err = err .. " Pull: " .. tostring(res2) end
    return 0, err
end

local function depositItems(items)
    if not chestConfig then return false, "No Config" end
    local cust = peripheral.wrap(chestConfig.customer)
    local bank = peripheral.wrap(chestConfig.bank)
    
    if not cust or not bank then return false, "Chest Missing" end
    
    local totalCredits = 0
    local lastError = nil
    
    for _, item in ipairs(items) do
        -- Move item from Customer to Bank using safe transfer
        local moved, err = safeTransfer(cust, chestConfig.customer, bank, chestConfig.bank, item.slot, item.count)
        
        if moved and moved > 0 and not item.garbage then
             local rate = RATES_INPUT[item.name]
             if rate then
                totalCredits = totalCredits + (moved * rate)
             end
        elseif err then
            lastError = err
        end
    end
    
    return true, totalCredits, lastError
end

local function withdrawItem(itemName, count)
    if not chestConfig then return 0 end
    local cust = peripheral.wrap(chestConfig.customer)
    local bank = peripheral.wrap(chestConfig.bank)
    if not cust or not bank then return 0 end
    
    -- Find item in Bank
    local transferred = 0
    for slot, item in pairs(bank.list()) do
        if item.name == itemName then
            local needed = count - transferred
            
            -- Bank -> Customer
            local pushed = safeTransfer(bank, chestConfig.bank, cust, chestConfig.customer, slot, needed)
            
            transferred = transferred + pushed
            if transferred >= count then break end
        end
    end
    
    return transferred
end

-- === MENUS ===

local function menuDeposit(cardPath)
    -- Initial scan
    local val, items = scanIOChest()
    
    while true do
        clear()
        centerText(2, "DEPOSIT ITEMS", colors.yellow)
        centerText(4, "Place items in chest", colors.white)
        centerText(5, "Diamonds (1), Obsidian (4)", colors.gray)
        centerText(6, "Eyes of Ender (16)", colors.gray)
        
        -- Sum only valid values for display
        local displayVal = 0
        for _, it in ipairs(items) do if not it.garbage then displayVal = displayVal + it.value end end
        
        if displayVal > 0 then
            centerText(8, "Detected: " .. displayVal .. " Credits", colors.lime)
        else
            centerText(8, "Scanning Chest...", colors.gray)
        end
        
        centerText(h-2, "[BTN 1] Confirm & Deposit", colors.lime)
        centerText(h-1, "[BTN 3] Back", colors.red)
        
        local timer = os.startTimer(0.5)
        local event, p1 = os.pullEvent()
        
        if event == "timer" then
             _, items = scanIOChest()
        else
            resetActivity()
            local btn = input.getButton(event, p1)
            
            if btn == "LEFT" then -- Button 1
                audio.playClick()
                -- Filter items list to ensure we actually have something to move (even garbage)
                if #items > 0 then
                    animateScanning(h-4)
                    local success, result, err = depositItems(items)
                    
                    if success then
                        if type(result) == "number" and result > 0 then
                             audio.playCashRegister()
                             credits.add(result, cardPath)
                             
                             clear()
                             centerText(h/2, "DEPOSIT SUCCESS", colors.lime)
                             centerText(h/2+1, "+" .. result .. " CREDITS", colors.yellow)
                             sleep(1.5)
                             return
                        elseif result == 0 then
                            -- Only garbage moved or transfer failed
                             clear()
                             if err and (string.find(err, "Target") or string.find(err, "target")) then
                                 centerText(h/2-2, "NETWORK ERROR", colors.red)
                                 centerText(h/2, "Chests cannot see each other", colors.white)
                                 centerText(h/2+1, "Connect WIRED MODEMS to BOTH", colors.yellow)
                                 centerText(h/2+2, "Chests/Barrels", colors.yellow)
                                 sleep(6)
                             else
                                 centerText(h/2, "Invalid Items Stored", colors.red)
                                 if err then
                                    centerText(h/2+2, string.sub(err, 1, 38), colors.gray) 
                                 end
                                 sleep(3.5)
                             end
                        else
                             audio.playError()
                             centerText(h-4, "Error: 0 Deposited", colors.red)
                             sleep(1)
                        end
                    else
                         audio.playError()
                         centerText(h-4, "Error: " .. tostring(result), colors.red)
                         sleep(2)
                    end
                    _, items = scanIOChest()
                else
                    audio.playError()
                    centerText(h-4, "Chest Empty", colors.red)
                    sleep(0.5)
                end
                
            elseif btn == "RIGHT" then -- Button 3
                audio.playClick()
                return
            end
        end
    end
end

local function menuWithdraw(cardPath)
    local currentSelection = 1 
    local options = {
        { name = "Diamond", id="minecraft:diamond", cost = 1, rate = 1, label="1 Credit -> 1 Diamond" },
        { name = "Ender Pearl", id="minecraft:ender_pearl", cost = 16, rate = 16, label="16 Credits -> 1 Pearl" }
    }
    
    while true do
        clear()
        local currentCreds = credits.get(cardPath)
        centerText(2, "CASH OUT", colors.yellow)
        centerText(3, "Credits: " .. currentCreds, colors.white)
        
        for i, opt in ipairs(options) do
            local y = 5 + (i * 3)
            local prefix = (i == currentSelection) and "> " or "  "
            local color = (i == currentSelection) and colors.lime or colors.gray
            centerText(y, prefix .. opt.name, color)
            centerText(y+1, "(" .. opt.label .. ")", colors.gray)
        end
        
        centerText(h-2, "[1] Select   [2] Confirm", colors.cyan)
        centerText(h-1, "[3] Back", colors.red)
        
        local event, p1 = os.pullEvent()
        resetActivity()
        local btn = input.getButton(event, p1)
        
        if btn == "LEFT" then -- Cycle Selection
            audio.playClick()
            currentSelection = currentSelection + 1
            if currentSelection > #options then currentSelection = 1 end
            
        elseif btn == "CENTER" then -- Confirm
            audio.playConfirm()
            local opt = options[currentSelection]
            
            if currentCreds >= opt.rate then
                clear()
                centerText(h/2-2, "Dispensing " .. opt.name, colors.white)
                
                local moved = withdrawItem(opt.id, 1)
                
                if moved and moved >= 1 then
                    animateDispense(h/2)
                    credits.remove(opt.rate, cardPath)
                    
                    clear()
                    centerText(h/2, "Please Take Item", colors.lime)
                    sleep(1)
                else
                    audio.playError()
                    centerText(h/2+2, "Bank Empty!", colors.red)
                    sleep(1.5)
                end
            else
                audio.playError()
                centerText(h-3, "Insufficient Credits!", colors.red)
                sleep(1)
            end
            
        elseif btn == "RIGHT" then -- Back
            audio.playClick()
            return
        end
    end
end

local function menuMain(cardPath)
    local lastCredits = credits.get(cardPath)

    while true do
        if not drive or not drive.isDiskPresent() then return end 
        
        local name = credits.getName(cardPath) or "Player"
        local bal = credits.get(cardPath)
        
        clear()
        centerText(2, "WELCOME, " .. string.upper(name), colors.cyan)
        
        -- Credits Display
        centerText(4, "CREDITS: " .. bal, colors.yellow)
        
        centerText(7, "[1] DEPOSIT Items", colors.white)
        centerText(9, "[2] CASH OUT", colors.white)
        centerText(11, "[3] EJECT CARD", colors.red)
        
        -- Fun check for items waiting
        local val, _ = scanIOChest()
        if val > 0 then
             centerText(h-1, "Items Detected! Use [1]", colors.lime)
        end
        
        local event, p1 = os.pullEvent()
        resetActivity()
        local btn = input.getButton(event, p1)
        
        if btn == "LEFT" then -- Deposit
            audio.playClick()
            menuDeposit(cardPath)
        elseif btn == "CENTER" then -- Cash Out
            audio.playClick()
            menuWithdraw(cardPath)
        elseif btn == "RIGHT" then -- Eject
            audio.playClick()
            if drive then drive.ejectDisk() end
            return
        end
    end
end

local function promptNewCard(cardPath)
    -- If card has no data/corrupt, init it
    if not credits.getName(cardPath) then
        credits.set(0, cardPath) 
    end
    menuMain(cardPath)
end



local function checkHardware()
    local errors = {}
    
    -- 1. Inventory Check
    allInventories = findAllInventories()
    if #allInventories < 2 then
        table.insert(errors, "Need 2 Connected Chests")
        table.insert(errors, "Found: " .. #allInventories)
    end
    
    -- 2. Speaker Check
    if not peripheral.find("speaker") then
        table.insert(errors, "Missing Speaker")
    end
    
    -- 3. Drive Check
    if not drive then
        table.insert(errors, "Missing Disk Drive")
    end
    
    -- 4. Redstone Config Check
    if not fs.exists(".button_config") then
        table.insert(errors, "Config Missing! Run config.lua")
    else
        local f = fs.open(".button_config", "r")
        local success, conf = pcall(function() return textutils.unserialize(f.readAll()) end)
        f.close()
        
        if not success or not conf or not conf.LEFT or not conf.CENTER or not conf.RIGHT then
            table.insert(errors, "Invalid Button Config")
        else
            local rsCount = 0
            if conf.LEFT.type == "redstone" then rsCount = rsCount + 1 end
            if conf.CENTER.type == "redstone" then rsCount = rsCount + 1 end
            if conf.RIGHT.type == "redstone" then rsCount = rsCount + 1 end
            
            if rsCount < 3 then
                table.insert(errors, "Need 3 Redstone Buttons")
            end
        end
    end
    
    if #errors > 0 then
        -- Force display to available output using standard print for safety
        term.setBackgroundColor(colors.black)
        term.clear()
        term.setCursorPos(1, 1)
        
        term.setTextColor(colors.red)
        print("HARDWARE CHECK FAILED")
        print("---------------------")
        
        term.setTextColor(colors.white)
        for i, err in ipairs(errors) do
            print("- " .. err)
        end
        
        print("")
        term.setTextColor(colors.yellow)
        print("Press any key to reboot...")
        os.pullEvent("key")
        os.reboot()
    end
    
    -- Config Wizard if needed
    configureChests()
    
    -- Success
    clear()
    centerText(h/2, "Hardware Verified", colors.lime)
    sleep(0.5)
end

-- === MAIN LOOP ===

local function main()
    checkHardware()

    while true do
        if not drive then
            clear()
            centerText(h/2, "Error: No Drive Found", colors.red)
            sleep(5)
            drive = peripheral.find("drive")
        else
            if drive.isDiskPresent() then
                resetActivity()
                local mount = drive.getMountPath()
                if mount then
                    promptNewCard(mount)
                else
                     sleep(0.5)
                end
            else
                -- IDLE STATE
                clear()
                centerText(h/2 - 1, "INSERT PLAYER CARD", colors.lime)
                
                -- Idle scan for customers putting things in input
                local val, _ = scanIOChest()
                if val > 0 then
                    resetActivity() 
                    centerText(h/2 + 1, "Items Detected!", colors.yellow)
                    centerText(h/2 + 2, "Insert Card to Deposit", colors.white)
                end
                
                if os.clock() - lastActivity > SCREENSAVER_TIMEOUT then
                    runScreensaver()
                end
                
                local timer = os.startTimer(1)
                local event, p1 = os.pullEvent()
                
                if event == "disk" then
                    resetActivity()
                elseif event == "timer" then
                    -- loop
                else
                    -- Input reset
                    local btn = input.getButton(event, p1)
                    if btn or event == "monitor_touch" or event == "mouse_click" or event == "char" or event == "key" then
                        resetActivity()
                    end
                end
            end
        end
    end
end

main()


]])

writeFile('config.lua', [[
-- config.lua
-- Button Configuration Wizard

local function clear()
    term.clear()
    term.setCursorPos(1, 1)
end

local function saveConfig(config)
    local file = fs.open(".button_config", "w")
    file.write(textutils.serialize(config))
    file.close()
end

local function waitForInput(buttonName)
    clear()
    print("BUTTON SETUP")
    print("============")
    print("")
    print("Please press the " .. buttonName .. " button.")
    print("(Press a Key or activate Redstone)")
    
    while true do
        local event, p1 = os.pullEvent()
        
        if event == "key" then
            -- p1 is key code
            return { type = "key", value = p1 }
            
        elseif event == "redstone" then
            -- Check all sides for active input
            for _, side in ipairs(rs.getSides()) do
                if rs.getInput(side) then
                    -- Wait for signal to turn off to avoid double detection?
                    -- For now, just accept it.
                    return { type = "redstone", value = side }
                end
            end
        end
    end
end

-- Main Wizard
local config = {}

-- 1. Left Button
config.LEFT = waitForInput("LEFT")
print("Captured!")
sleep(0.5)

-- 2. Center Button
config.CENTER = waitForInput("CENTER")
print("Captured!")
sleep(0.5)

-- 3. Right Button
config.RIGHT = waitForInput("RIGHT")
print("Captured!")
sleep(0.5)

-- Save
saveConfig(config)

clear()
print("Configuration Saved!")
print("Left: " .. config.LEFT.type .. " " .. config.LEFT.value)
print("Center: " .. config.CENTER.type .. " " .. config.CENTER.value)
print("Right: " .. config.RIGHT.type .. " " .. config.RIGHT.value)
print("")
print("Continuing startup...")
sleep(2)

]])

writeFile('credits.lua', [[
local DEFAULT_CREDITS = 0 
local DEFAULT_NAME = "Guest"

local credits = {}

local function getFilePath(mountPath)
    return (mountPath or "disk") .. "/credits.json"
end

local function readData(mountPath)
    local path = getFilePath(mountPath)
    if not fs.exists(path) then
        return nil
    end
    
    local f = fs.open(path, "r")
    if not f then return nil end
    local content = f.readAll()
    f.close()
    
    local data = textutils.unserializeJSON(content)
    return data
end

local function writeData(mountPath, data)
    local path = getFilePath(mountPath)
    -- Only write if the directory exists (disk is present)
    local dir = fs.getDir(path)
    if not fs.exists(dir) then
        return false 
    end

    local f = fs.open(path, "w")
    if f then
        f.write(textutils.serializeJSON(data))
        f.close()
        return true
    end
    return false
end

-- Find all connected disks with credits info
function credits.findCards()
    local cards = {}
    for _, side in ipairs(peripheral.getNames()) do
        if peripheral.getType(side) == "drive" then
            local path = disk.getMountPath(side)
            if path then
                local data = readData(path)
                if data then
                    table.insert(cards, {
                        path = path, 
                        side = side,
                        name = data.name or DEFAULT_NAME,
                        credits = data.credits or DEFAULT_CREDITS
                    })
                end
            end
        end
    end
    return cards
end

function credits.get(mountPath)
    if _G.ARCADE_DEV_MODE then
        return math.huge
    end

    local data = readData(mountPath)
    if not data or not data.credits then
        return DEFAULT_CREDITS
    end
    
    return tonumber(data.credits) or DEFAULT_CREDITS
end

function credits.getName(mountPath)
    local data = readData(mountPath)
    if not data or not data.name then
        return nil
    end
    return data.name
end

function credits.set(amount, mountPath)
    if _G.ARCADE_DEV_MODE then
        return true 
    end

    local data = readData(mountPath) or { name = DEFAULT_NAME }
    data.credits = math.floor(amount)
    
    return writeData(mountPath, data)
end

function credits.add(amount, mountPath)
    local current = credits.get(mountPath)
    local newAmount = current + amount
    credits.set(newAmount, mountPath)
    return newAmount
end

function credits.remove(amount, mountPath)
    if _G.ARCADE_DEV_MODE then
        return true 
    end

    local current = credits.get(mountPath)
    if current >= amount then
        credits.set(current - amount, mountPath)
        return true
    else
        return false
    end
end

function credits.lock(mountPath)
    local data = readData(mountPath)
    if data then
        data.in_game = true
        writeData(mountPath, data)
    end
end

function credits.unlock(mountPath)
    local data = readData(mountPath)
    if data then
        data.in_game = false
        writeData(mountPath, data)
    end
end

return credits

]])

writeFile('exchange.lua', [[
local credits = require("credits")
local completion = require("cc.completion")

-- Configuration
local PRICES = {
    ["minecraft:diamond"] = 1,
    ["minecraft:obsidian"] = 4,
    ["minecraft:ender_eye"] = 16
}

local mon = peripheral.find("monitor")
local drive = peripheral.find("drive")
local chest = nil
local storage = nil

-- Attempt to find chests/inventories
local periphs = peripheral.getNames()
for _, name in ipairs(periphs) do
    if peripheral.getType(name) == "minecraft:chest" or peripheral.getType(name) == "minecraft:barrel" then
        if not chest then
            chest = peripheral.wrap(name)
        elseif not storage then
            storage = peripheral.wrap(name)
        end
    end
end

-- If only one chest found, assume we are a turtle or we void items? 
-- The user said "sucked in". 
-- If we are a command computer, maybe we can clearslot?
-- For now, if no storage, we will just count and NOT move (safety) unless we are a turtle.
local is_turtle = turtle ~= nil

local function getDriveSide()
    for _, name in ipairs(periphs) do
        if peripheral.getType(name) == "drive" then
            return name
        end
    end
    return nil
end

local driveSide = getDriveSide()

local interacting = false

local function showAttract()
    if not mon then return end
    mon.setTextScale(1)
    mon.setBackgroundColor(colors.black)
    
    local w, h = mon.getSize()
    local colors_list = {colors.red, colors.orange, colors.yellow, colors.lime, colors.blue, colors.purple}
    
    local i = 1
    while true do
        if not interacting then
            mon.setBackgroundColor(colors.black)
            mon.clear()
            mon.setCursorPos(1, h/2)
            mon.setTextColor(colors_list[i])
            mon.setTextScale(2)
            local msg = "TURN IN COINS!"
            -- Center roughly
            mon.setCursorPos(3, 2) 
            mon.write(msg)
            
            mon.setTextScale(1)
            mon.setCursorPos(1, h-2)
            mon.setTextColor(colors.white)
            mon.write("No Disk? Check Chest!")
            
            i = i + 1
            if i > #colors_list then i = 1 end
            sleep(0.5)
        else
            sleep(0.5)
        end
    end
end

local function drawStatus(msg, color)
    if not mon then return end
    mon.setBackgroundColor(colors.black)
    mon.clear()
    mon.setCursorPos(1, 1)
    mon.setTextColor(color or colors.white)
    mon.setTextScale(1)
    mon.write(msg)
end

local function launchFireworks()
    -- Only works if command computer or configured
    if commands then
       -- Summon random firework
       commands.exec("summon firework_rocket ~ ~2 ~ {LifeTime:15,FireworksItem:{id:firework_rocket,Count:1,tag:{Fireworks:{Flight:1,Explosions:[{Type:1,Flicker:1,Trail:1,Colors:[I;11743532],FadeColors:[I;11743532]}]}}}}")
    else
        -- Fallback sound or visualization could go here
    end
end

local function processItems(mountPath)
    if not chest then return end
    
    local total_credit_gain = 0
    
    -- Iterate all slots
    for slot, item in pairs(chest.list()) do
        if PRICES[item.name] then
            local value = PRICES[item.name]
            local count = item.count
            local gain = value * count
            
            -- Move logic
            local moved = false
            if storage then
                -- Push to storage
                local pushed = chest.pushItems(peripheral.getName(storage), slot)
                if pushed == count then moved = true end
            elseif is_turtle then
                -- Turtle suck (must be facing chest)
                -- This is tricky if we don't know orientation. 
                -- We'll assume standard computer behavior first.
            else
                 -- WE CANNOT DESTROY ITEMS SAFELY WITHOUT STORAGE
                 -- but maybe the user wants us to?
                 -- User said "sucked in". 
                 -- Let's try to push to ANY other inventory found that is not the drive.
                 for _, p in ipairs(peripheral.getNames()) do
                    if p ~= peripheral.getName(chest) and p ~= peripheral.getName(drive) and peripheral.getType(p) ~= "monitor" and peripheral.getType(p) ~= "modem" then
                        -- try push
                        local pushed = chest.pushItems(p, slot)
                        if pushed >= count then 
                            moved = true 
                            break 
                        end
                    end
                 end
            end
            
            if moved then
                total_credit_gain = total_credit_gain + gain
                -- print("Processed " .. item.name .. " x" .. count .. " = " .. gain)
            else
                -- Could not move items
                if mon then
                     local w, h = mon.getSize()
                     mon.setCursorPos(1, h-1)
                     mon.setTextColor(colors.red)
                     mon.write("ERR: CANNOT MOVE ITEM")
                     sleep(1)
                     mon.setCursorPos(1, h-1)
                     mon.clearLine()
                end
            end
        end
    end
    
    if total_credit_gain > 0 then
        credits.add(total_credit_gain, mountPath)
        return total_credit_gain
    end
    return 0
end

local function mainLoop()
    local hadDisk = false
    
    while true do
        local hasDisk = disk.isPresent(driveSide)
        local mountPath = disk.getMountPath(driveSide)
        
        if hasDisk and mountPath then
            interacting = true
            if not hadDisk then
                if mon then
                    mon.setBackgroundColor(colors.black) -- Clear animation
                    mon.clear()
                end
                hadDisk = true
            end
            
            -- User logic
            local current = credits.get(mountPath)
            local name = credits.getName(mountPath) or "Guest"
            
            if mon then
                mon.setCursorPos(1,1)
                mon.setTextColor(colors.lime)
                mon.write("Welcome, " .. name)
                mon.setCursorPos(1,2)
                mon.write("Credits: " .. current)
                mon.setCursorPos(1,4)
                mon.setTextColor(colors.white)
                mon.write("Place items in chest...")
            end
            
            local gained = processItems(mountPath)
            if gained > 0 then
                if mon then
                    mon.setCursorPos(1,6)
                    mon.setTextColor(colors.yellow)
                    mon.write("Added: " .. gained .. " credits!")
                    sleep(1)
                    mon.setCursorPos(1,6) 
                    mon.clearLine()
                end
            end
            
        else
            -- No disk
            interacting = false
            if hadDisk then hadDisk = false end
            
            -- Check if someone is interacting (e.g. items in chest but no disk)
            local chestHasItems = false
            if chest then
                local list = chest.list()
                if list then
                    for slot, item in pairs(list) do
                        if PRICES[item.name] then
                            chestHasItems = true
                            break
                        end
                    end
                end
            end

            if chestHasItems then
                -- "Throws fireworks and encourages them"
                launchFireworks()
                -- We rely on parallel animation to show "TURN IN COINS" / "INSERT DISK"
                sleep(2) -- Don't spam fireworks
            end
        end
        
        sleep(0.5)
    end
end

-- Run
if not mon then
    print("Error: No monitor found.")
    return
end

parallel.waitForAny(showAttract, mainLoop)

]])

writeFile('input.lua', [[
-- input.lua
-- Input handling for Arcade OS

local config = {
    LEFT = { type = "key", value = keys.left },
    CENTER = { type = "key", value = keys.up },
    RIGHT = { type = "key", value = keys.right }
}

-- Load config if exists
if fs.exists(".button_config") then
    local file = fs.open(".button_config", "r")
    if file then
        local data = file.readAll()
        file.close()
        local loaded = textutils.unserialize(data)
        if loaded then
            config = loaded
        end
    end
end

-- Also support default keys for keyboard fallback
local DEFAULT_KEYS = {
    LEFT = { keys.left, keys.a, keys.q },
    CENTER = { keys.up, keys.w, keys.space, keys.enter },
    RIGHT = { keys.right, keys.d, keys.e }
}

local function isKey(key, set)
    for _, k in ipairs(set) do
        if key == k then return true end
    end
    return false
end

local function getButton(event, p1)
    if event == "key" then
        -- Check configured keys
        if config.LEFT.type == "key" and p1 == config.LEFT.value then return "LEFT" end
        if config.CENTER.type == "key" and p1 == config.CENTER.value then return "CENTER" end
        if config.RIGHT.type == "key" and p1 == config.RIGHT.value then return "RIGHT" end
        
        -- Check default keys (fallback/keyboard support)
        if isKey(p1, DEFAULT_KEYS.LEFT) then return "LEFT" end
        if isKey(p1, DEFAULT_KEYS.CENTER) then return "CENTER" end
        if isKey(p1, DEFAULT_KEYS.RIGHT) then return "RIGHT" end
        
    elseif event == "redstone" then
        -- Check configured redstone
        if config.LEFT.type == "redstone" and redstone.getInput(config.LEFT.value) then return "LEFT" end
        if config.CENTER.type == "redstone" and redstone.getInput(config.CENTER.value) then return "CENTER" end
        if config.RIGHT.type == "redstone" and redstone.getInput(config.RIGHT.value) then return "RIGHT" end
        
        -- Default redstone fallback (Legacy support)
        -- Only check if NOT configured as redstone to avoid double counting if config matches default
        if config.LEFT.type ~= "redstone" and redstone.getInput("left") then return "LEFT" end
        if config.RIGHT.type ~= "redstone" and redstone.getInput("right") then return "RIGHT" end
        if config.CENTER.type ~= "redstone" and (redstone.getInput("top") or redstone.getInput("front")) then return "CENTER" end
    end
    return nil
end

return {
    getButton = getButton
}

]])

writeFile('menu.lua', [[
-- menu.lua
-- The lightweight Arcade OS Shell
-- Controls: [Left] Prev, [Center] Launch, [Right] Next

local games = {
    { name = "Blackjack", cmd = "blackjack" },
    { name = "Super Slots", cmd = "slots" },
    { name = "Can't Stop", cmd = "cant_stop" },
    { name = "RPS Rogue", cmd = "rps_rogue" },
    { name = "Exit", cmd = "exit" },
    { name = "Reboot", cmd = "reboot" },
    { name = "Shutdown", cmd = "shutdown" }
}

local selected = 1
local w, h = term.getSize()

local input = require("input")
local credits = require("credits")
local audio = require("audio")

local function drawHeader()
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.yellow)
    term.setCursorPos(1, 1)
    term.clearLine()
    term.setCursorPos(2, 1)
    term.write("ARCADE OS")
    
    local c = credits.get()
    local name = credits.getName()

    local rightText = "Credits: " .. c
    if name then
        rightText = name .. " | " .. rightText
    end

    term.setCursorPos(w - #rightText - 1, 1)
    term.write(rightText)
end

local function drawMenu()
    term.setBackgroundColor(colors.black)
    term.clear()
    drawHeader()
    
    local centerY = math.floor(h / 2)
    
    for i, game in ipairs(games) do
        local y = centerY - 2 + i
        if y >= 2 and y < h then
            term.setCursorPos(2, y)
            if i == selected then
                term.setTextColor(colors.lime)
                term.write("> " .. game.name .. " <")
            else
                term.setTextColor(colors.white)
                term.write("  " .. game.name)
            end
        end
    end
    
    -- Footer
    term.setBackgroundColor(colors.gray)
    term.setTextColor(colors.black)
    term.setCursorPos(1, h)
    term.clearLine()
    term.write(" [L] Prev  [C] Launch  [R] Next  [S] Monitor")
end

local function launchGame()
    local game = games[selected]
    term.setBackgroundColor(colors.black)
    term.clear()
    term.setCursorPos(1, 1)
    
    if game.cmd == "reboot" then
        os.reboot()
    elseif game.cmd == "shutdown" then
        os.shutdown()
    elseif game.cmd == "exit" then
        return true
    else
        if fs.exists(game.cmd .. ".lua") then
            shell.run(game.cmd)
        else
            print("Game not installed: " .. game.cmd)
            sleep(1)
        end
    end
    return false
end

local function main()
    while true do
        drawMenu()
        
        local event, p1 = os.pullEvent()
        local button = input.getButton(event, p1)
        
        if button == "LEFT" then
            selected = selected - 1
            if selected < 1 then selected = #games end
            audio.playClick()
            if event == "redstone" then sleep(0.2) end
        elseif button == "RIGHT" then
            selected = selected + 1
            if selected > #games then selected = 1 end
            audio.playClick()
            if event == "redstone" then sleep(0.2) end
        elseif button == "CENTER" then
            audio.playConfirm()
            if launchGame() then break end
            if event == "redstone" then sleep(0.2) end
        elseif event == "char" and p1:lower() == "s" then
            local m = peripheral.find("monitor")
            if m then
                audio.playConfirm()
                term.setBackgroundColor(colors.black)
                term.setTextColor(colors.white)
                term.clear()
                term.setCursorPos(1, 1)
                print("Monitor detected.")
                print("Rebooting to switch display...")
                sleep(1)
                os.reboot()
            else
                audio.playLose()
            end
        elseif event == "disk" then
             local name = credits.getName()
             local amount = credits.get()
             if name then
                audio.playConfirm()
                local popupW, popupH = 24, 7
                local px = math.floor((w - popupW) / 2)
                local py = math.floor((h - popupH) / 2)
                
                -- Draw box
                paintutils.drawFilledBox(px, py, px + popupW, py + popupH, colors.blue)
                term.setTextColor(colors.yellow)
                term.setCursorPos(px + 2, py + 1)
                term.write("WELCOME BACK!")
                
                term.setTextColor(colors.white)
                term.setCursorPos(px + 2, py + 3)
                term.write(name)
                
                term.setCursorPos(px + 2, py + 5)
                term.write("Credits: " .. amount)
                
                sleep(3)
             end
        end
    end
end

main()

]])

writeFile('rps_rogue.lua', [[
-- rps_rogue.lua
-- Rock-Paper-Scissors Roguelike

local w, h = term.getSize()

-- 3-Button Config
local input = require("input")

local function waitKey()
    while true do
        local e, p1 = os.pullEvent()
        local button = input.getButton(e, p1)
        if button then
            if e == "redstone" then sleep(0.2) end
            return button
        end
    end
end

--------------------------------------------------------------------------------
-- GAME LOGIC
--------------------------------------------------------------------------------

local MOVES = { "Rock", "Paper", "Scissors" }
local BEATS = { Rock = "Scissors", Paper = "Rock", Scissors = "Paper" }

local player = { hp = 20, maxHp = 20, dmg = 3, level = 1 }
local enemy = { hp = 10, maxHp = 10, dmg = 2, name = "Slime" }
local floor = 1
local log = {}

local function addLog(msg)
    table.insert(log, 1, msg)
    if #log > 5 then table.remove(log) end
end

local function generateEnemy()
    local types = {
        {name="Slime", hp=10, dmg=2},
        {name="Goblin", hp=15, dmg=3},
        {name="Orc", hp=25, dmg=4},
        {name="Dragon", hp=50, dmg=8}
    }
    local idx = math.min(#types, math.floor((floor-1)/3) + 1)
    if floor > 10 then idx = 4 end
    
    local base = types[idx]
    enemy = {
        name = base.name,
        hp = base.hp + math.floor(floor * 1.5),
        maxHp = base.hp + math.floor(floor * 1.5),
        dmg = base.dmg + math.floor(floor * 0.5)
    }
end

local function resolveRound(pMove, eMove)
    addLog("You: " .. pMove .. " vs " .. eMove)
    
    if pMove == eMove then
        addLog("Draw!")
    elseif BEATS[pMove] == eMove then
        addLog("Hit! Dealt " .. player.dmg .. " dmg.")
        enemy.hp = enemy.hp - player.dmg
        audio.playClick()
    else
        addLog("Ouch! Took " .. enemy.dmg .. " dmg.")
        player.hp = player.hp - enemy.dmg
        audio.playLose()
    end
end

--------------------------------------------------------------------------------
-- UI
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- UI
--------------------------------------------------------------------------------

local function drawText(x, y, text, fg, bg)
    term.setCursorPos(x, y)
    if fg then term.setTextColor(fg) end
    if bg then term.setBackgroundColor(bg) end
    term.write(text)
end

local function drawFooter(c1, c2, c3)
    local colW = math.floor(w / 3)
    
    -- Left Button
    term.setCursorPos(1, h)
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", colW))
    drawText(math.floor(colW/2 - #c1/2)+1, h, c1, colors.white, colors.red)
    
    -- Center Button
    term.setCursorPos(colW + 1, h)
    term.setBackgroundColor(colors.yellow)
    term.setTextColor(colors.black)
    term.write(string.rep(" ", colW))
    drawText(colW + math.floor(colW/2 - #c2/2)+1, h, c2, colors.black, colors.yellow)
    
    -- Right Button
    term.setCursorPos(colW * 2 + 1, h)
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", w - (colW*2)))
    drawText(colW*2 + math.floor((w - colW*2)/2 - #c3/2)+1, h, c3, colors.white, colors.blue)
end

local function drawBar(label, val, max, y, color)
    term.setCursorPos(2, y)
    term.setTextColor(color)
    term.write(label .. ": " .. val .. "/" .. max)
    
    local barW = 10
    local fill = math.ceil((val/max) * barW)
    term.setCursorPos(2, y+1)
    term.setBackgroundColor(color)
    term.write(string.rep(" ", fill))
    term.setBackgroundColor(colors.gray)
    term.write(string.rep(" ", barW - fill))
    term.setBackgroundColor(colors.black)
end

local function drawUI()
    term.setBackgroundColor(colors.black)
    term.clear()
    
    -- Header
    term.setCursorPos(1, 1)
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.clearLine()
    term.write(" FLOOR " .. floor .. " - " .. enemy.name)
    
    -- Stats
    drawBar("PLAYER", player.hp, player.maxHp, 3, colors.lime)
    drawBar("ENEMY", enemy.hp, enemy.maxHp, 3, colors.red)
    
    -- Enemy is on the right
    term.setCursorPos(w - 15, 3)
    term.setTextColor(colors.red)
    term.write(enemy.name)
    term.setCursorPos(w - 15, 4)
    term.write("HP: " .. enemy.hp .. "/" .. enemy.maxHp)
    
    -- Log
    term.setCursorPos(2, 8)
    term.setTextColor(colors.white)
    term.write("--- LOG ---")
    for i, msg in ipairs(log) do
        term.setCursorPos(2, 9 + i)
        term.setTextColor(colors.lightGray)
        term.write(msg)
    end
    
    -- Controls
    term.setCursorPos(1, h)
    drawFooter("Rock", "Paper", "Scissors")
end

local function drawUpgradeMenu()
    term.setBackgroundColor(colors.black)
    term.clear()
    term.setCursorPos(1, 1)
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.yellow)
    term.clearLine()
    term.write(" LEVEL UP! Choose Upgrade:")
    
    term.setCursorPos(1, h)
    drawFooter("Heal Full", "+5 Max HP", "+1 Damage")
end

--------------------------------------------------------------------------------
-- MAIN LOOP
--------------------------------------------------------------------------------

local creditsAPI = require("credits")
local audio = require("audio")

local function main()
    if creditsAPI.get() < 5 then
        term.clear()
        term.setCursorPos(1, h/2)
        term.setTextColor(colors.red)
        term.write("Insert Coin: 5 Credits")
        sleep(2)
        return
    end
    creditsAPI.remove(5)

    generateEnemy()
    
    while true do
        if player.hp <= 0 then
            term.clear()
            term.setCursorPos(1, h/2)
            term.setTextColor(colors.red)
            term.write("GAME OVER")
            term.setCursorPos(1, h/2 + 1)
            term.write("Reached Floor " .. floor)
            audio.playLose()
            sleep(3)
            break
        end
        
        if enemy.hp <= 0 then
            -- Victory
            floor = floor + 1
            player.level = player.level + 1
            creditsAPI.add(5) -- Reward for clearing floor
            audio.playWin()
            
            -- Upgrade
            drawUpgradeMenu()
            local key = waitKey()
            if key == "LEFT" then
                player.hp = player.maxHp
            elseif key == "CENTER" then
                player.maxHp = player.maxHp + 5
                player.hp = player.hp + 5
            elseif key == "RIGHT" then
                player.dmg = player.dmg + 1
            end
            audio.playConfirm()
            
            generateEnemy()
            log = {}
            addLog("Floor " .. floor .. " start!")
        else
            drawUI()
            local key = waitKey()
            local pMove = nil
            if key == "LEFT" then pMove = "Rock"
            elseif key == "CENTER" then pMove = "Paper"
            elseif key == "RIGHT" then pMove = "Scissors" end
            
            if pMove then
                local eMove = MOVES[math.random(1, 3)]
                resolveRound(pMove, eMove)
            end
        end
    end
    
    if fs.exists("menu.lua") then shell.run("menu.lua") end
end

main()

]])

writeFile('setup.lua', [[
-- setup.lua
-- Initial Configuration Menu
-- Select the game to permanently install on this machine

local games = {
    { name = "Blackjack", cmd = "blackjack" },
    { name = "Super Slots", cmd = "slots" },
    { name = "Can't Stop", cmd = "cant_stop" },
    { name = "RPS Rogue", cmd = "rps_rogue" },
    { name = "Exchange", cmd = "exchange" },
    { name = "Cashier System", cmd = "cashier" }
}

local selected = 1
local w, h = term.getSize()

local input = require("input")
local audio = require("audio")

local function drawHeader()
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.setCursorPos(1, 1)
    term.clearLine()
    term.setCursorPos(2, 1)
    term.write("SYSTEM SETUP - ONE TIME ONLY")
end

local function drawMenu()
    term.setBackgroundColor(colors.black)
    term.clear()
    drawHeader()
    
    local centerY = math.floor(h / 2)
    
    term.setCursorPos(2, 3)
    term.setTextColor(colors.gray)
    term.write("Select Game to Install:")

    for i, game in ipairs(games) do
        local y = centerY - 1 + i
        if y >= 4 and y < h then
            term.setCursorPos(2, y)
            if i == selected then
                term.setTextColor(colors.lime)
                term.write("> " .. game.name .. " <")
            else
                term.setTextColor(colors.white)
                term.write("  " .. game.name)
            end
        end
    end
    
    -- Footer
    term.setBackgroundColor(colors.gray)
    term.setTextColor(colors.black)
    term.setCursorPos(1, h)
    term.clearLine()
    term.write(" [L] Prev  [C] INSTALL  [R] Next")
end

local function installGame()
    local game = games[selected]
    term.setBackgroundColor(colors.black)
    term.clear()
    term.setCursorPos(1, 1)
    print("Installing " .. game.name .. "...")
    
    local file = fs.open(".arcade_config", "w")
    file.write(game.cmd)
    file.close()
    
    print("Configuration saved.")
    print("Rebooting in 2 seconds...")
    sleep(2)
    os.reboot()
end

local function main()
    while true do
        drawMenu()
        
        local event, p1 = os.pullEvent()
        local button = input.getButton(event, p1)
        
        if button == "LEFT" then
            selected = selected - 1
            if selected < 1 then selected = #games end
            audio.playClick()
            if event == "redstone" then sleep(0.2) end
        elseif button == "RIGHT" then
            selected = selected + 1
            if selected > #games then selected = 1 end
            audio.playClick()
            if event == "redstone" then sleep(0.2) end
        elseif button == "CENTER" then
            audio.playConfirm()
            installGame()
            break
        end
    end
end

main()

]])

writeFile('slots.lua', [[
-- slots.lua
-- 3-Button Slot Machine (Multiplayer Edition)

local w, h = term.getSize()
local cx, cy = math.floor(w / 2), math.floor(h / 2)

local input = require("input")
local creditsAPI = require("credits")
local audio = require("audio")

local function waitKey()
    while true do
        local e, p1 = os.pullEvent()
        local button = input.getButton(e, p1)
        if button then
            if e == "redstone" then sleep(0.2) end
            return button
        end
    end
end

local function drawText(x, y, text, fg, bg)
    term.setCursorPos(x, y)
    if fg then term.setTextColor(fg) end
    if bg then term.setBackgroundColor(bg) end
    term.write(text)
end

local function drawCenter(y, text, fg, bg)
    local x = math.floor((w - #text)/2) + 1
    drawText(x, y, text, fg, bg)
end

--------------------------------------------------------------------------------
-- GAME CONFIG
--------------------------------------------------------------------------------

local SYMBOLS = {"Cherry", "Lemon", "Orange", "Plum", "Bell", "Bar", "7"}
local COLORS = {
    Cherry = colors.red, Lemon = colors.yellow, Orange = colors.orange,
    Plum = colors.purple, Bell = colors.gold or colors.yellow,
    Bar = colors.lightGray, ["7"] = colors.red
}
local CHARS = {
    Cherry = "@", Lemon = "O", Orange = "O", Plum = "%",
    Bell = "A", Bar = "=", ["7"] = "7"
}
local PAYOUTS = {
    Cherry = 5, Lemon = 10, Orange = 20, Plum = 50,
    Bell = 100, Bar = 250, ["7"] = 500
}

local REELS = {}
for i=1,3 do
    REELS[i] = {}
    for j=1,32 do
        local r = math.random()
        local s
        if r < 0.05 then s = "7"
        elseif r < 0.15 then s = "Bar"
        elseif r < 0.25 then s = "Bell"
        elseif r < 0.40 then s = "Plum"
        elseif r < 0.60 then s = "Orange"
        elseif r < 0.80 then s = "Lemon"
        else s = "Cherry" end
        table.insert(REELS[i], s)
    end
end

--------------------------------------------------------------------------------
-- DRAWING
--------------------------------------------------------------------------------

local function drawFooter(c1, c2, c3)
    local colW = math.floor(w / 3)
    
    -- Left Button
    term.setCursorPos(1, h)
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", colW))
    drawText(math.floor(colW/2 - #c1/2)+1, h, c1, colors.white, colors.red)
    
    -- Center Button
    term.setCursorPos(colW + 1, h)
    term.setBackgroundColor(colors.yellow)
    term.setTextColor(colors.black)
    term.write(string.rep(" ", colW))
    drawText(colW + math.floor(colW/2 - #c2/2)+1, h, c2, colors.black, colors.yellow)
    
    -- Right Button
    term.setCursorPos(colW * 2 + 1, h)
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.white)
    term.write(string.rep(" ", w - (colW*2)))
    drawText(colW*2 + math.floor((w - colW*2)/2 - #c3/2)+1, h, c3, colors.white, colors.blue)
end

local reelPos = {1, 1, 1}

local function drawReel(idx, x, y)
    -- Draw Frame around reel
    term.setBackgroundColor(colors.gray)
    for i=-1, 3 do
        term.setCursorPos(x-1, y+i*3-1)
        term.write("      ") -- Clear/Bg
    end
    
    for i=0,2 do
        local pos = (reelPos[idx] + i - 1) % #REELS[idx] + 1
        local sym = REELS[idx][pos]
        term.setCursorPos(x, y + i*3)
        term.setBackgroundColor(colors.white)
        term.setTextColor(COLORS[sym])
        term.write(" " .. CHARS[sym] .. CHARS[sym] .. " ")
        term.setBackgroundColor(colors.black)
    end
end

local function drawMachine(bet, message, currentPlayerName, currentCredits)
    term.setBackgroundColor(colors.black)
    term.clear()
    
    -- Title
    term.setCursorPos(1, 1)
    term.setBackgroundColor(colors.blue)
    term.setTextColor(colors.yellow)
    term.clearLine()
    drawCenter(1, " SUPER SLOTS ", colors.yellow, colors.blue)
    
    -- Machine Box
    local boxW, boxH = 26, 13
    local bx, by = cx - 13, cy - 6
    term.setBackgroundColor(colors.lightGray)
    for i=0, boxH do
        term.setCursorPos(bx, by+i)
        term.write(string.rep(" ", boxW))
    end
    
    -- Draw Reels
    local startX = cx - 8
    local startY = cy - 4
    for i=1,3 do
        drawReel(i, startX + (i-1)*6, startY)
    end
    
    -- Payline Indicators
    term.setBackgroundColor(colors.lightGray)
    term.setTextColor(colors.red)
    if bet >= 1 then term.setCursorPos(startX-2, startY+3) term.write(">") end -- Center
    if bet >= 2 then term.setCursorPos(startX-2, startY+0) term.write(">") end -- Top
    if bet >= 3 then term.setCursorPos(startX-2, startY+6) term.write(">") end -- Bottom
    
    -- Player Info
    term.setBackgroundColor(colors.black)
    term.setCursorPos(1, h-2)
    term.setTextColor(colors.white)
    if currentPlayerName then
        term.write("Player: " .. currentPlayerName)
        drawText(1, h-3, "Credits: " .. currentCredits, colors.gold, colors.black)
    end
    
    term.setCursorPos(w-10, h-2)
    term.write("Bet: " .. bet)
    
    -- Message
    term.setCursorPos(2, h-4)
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.yellow)
    drawCenter(h-4, message, colors.yellow, colors.black)
    
    -- Footer
    drawFooter("Bet", "Spin", "Exit")
end

local function spin(player)
    if creditsAPI.get(player.mountPath) < player.bet then
        return "Not enough credits!"
    end
    
    creditsAPI.remove(player.bet, player.mountPath)
    
    -- Animation
    for i=1,20 do
        for r=1,3 do reelPos[r] = (reelPos[r] % #REELS[r]) + 1 end
        drawMachine(player.bet, "Spinning...", player.name, creditsAPI.get(player.mountPath))
        audio.playShuffle()
        sleep(0.05)
    end
    
    -- Stop one by one
    for r=1,3 do
        for i=1,10 do
            reelPos[r] = (reelPos[r] % #REELS[r]) + 1
            for k=r+1,3 do reelPos[k] = (reelPos[k] % #REELS[k]) + 1 end
            drawMachine(player.bet, "Spinning...", player.name, creditsAPI.get(player.mountPath))
            sleep(0.05 + i*0.01)
        end
        audio.playSlotStop()
    end
    
    -- Check Win
    local win = 0
    local function getSym(r, offset)
        return REELS[r][(reelPos[r] + offset - 1) % #REELS[r] + 1]
    end
    
    local function checkLine(offset)
        local s1, s2, s3 = getSym(1, offset), getSym(2, offset), getSym(3, offset)
        if s1 == s2 and s2 == s3 then return PAYOUTS[s1] end
        if s1 == "Cherry" and s2 == "Cherry" then return 5 end
        return 0
    end
    
    if player.bet >= 1 then win = win + checkLine(1) end -- Center (offset 1)
    if player.bet >= 2 then win = win + checkLine(0) end -- Top (offset 0)
    if player.bet >= 3 then win = win + checkLine(2) end -- Bottom (offset 2)
    
    if win > 0 then
        creditsAPI.add(win, player.mountPath)
        audio.playWin()
        
        -- Flash Effect
        for i=1,3 do
            drawMachine(player.bet, "WINNER! " .. win, player.name, creditsAPI.get(player.mountPath))
            sleep(0.1)
            term.setBackgroundColor(colors.lime)
            term.clear()
            sleep(0.1)
        end
        return "WINNER! " .. win
    else
        audio.playLose()
        return "Try again!"
    end
end

--------------------------------------------------------------------------------
-- MAIN LOOP
--------------------------------------------------------------------------------

local function main()
    while true do
        term.setBackgroundColor(colors.black)
        term.clear()
        drawCenter(h/2 - 2, "SUPER SLOTS", colors.gold, colors.black)
        drawCenter(h/2, "Insert Cards (Max 3)", colors.white, colors.black)
        drawCenter(h/2 + 2, "[C] Start Game   [R] Exit", colors.gray, colors.black)
        
        -- Lobby Loop
        local detectedCards = {}
        while true do
            local event, p1 = os.pullEvent()
            if event == "key" then
                local key = keys.getName(p1)
                if key == "enter" or key == "space" then -- Start
                    if #detectedCards > 0 then break end
                    drawCenter(h/2 + 4, "No players detected!", colors.red, colors.black)
                    sleep(1)
                    term.setCursorPos(1, h/2+4) term.clearLine()
                elseif key == "backspace" or key == "e" then -- Exit
                     term.setBackgroundColor(colors.black)
                     term.clear()
                     if fs.exists("menu.lua") then shell.run("menu.lua") end
                     return
                end
            elseif event == "disk" or event == "disk_eject" then
                -- Refresh cards
                detectedCards = creditsAPI.findCards()
                term.setCursorPos(1, h/2 + 4)
                term.clearLine()
                local msg = "Players: "
                for i, c in ipairs(detectedCards) do
                    msg = msg .. c.name .. " "
                end
                drawCenter(h/2 + 4, msg, colors.yellow, colors.black)
            end
            
            -- Initial scan
             if #detectedCards == 0 then
                 detectedCards = creditsAPI.findCards()
                 if #detectedCards > 0 then
                    term.setCursorPos(1, h/2 + 4)
                    term.clearLine()
                    local msg = "Players: "
                    for i, c in ipairs(detectedCards) do
                        msg = msg .. c.name .. " "
                    end
                    drawCenter(h/2 + 4, msg, colors.yellow, colors.black)
                end
            end
        end
        
        local players = {}
        for i, card in ipairs(detectedCards) do
            if i > 3 then break end
            creditsAPI.lock(card.path)
            table.insert(players, {
                bet=1, 
                name=card.name,
                mountPath=card.path 
            })
        end
        
        -- Game Loop
        local msg = "Welcome!"
        while true do
            local allQuit = false
            
            for i, p in ipairs(players) do
                while true do
                    drawMachine(p.bet, p.name .. ": " .. msg, p.name, creditsAPI.get(p.mountPath))
                    local action = waitKey()
                    
                    if action == "LEFT" then
                        p.bet = (p.bet % 3) + 1
                        audio.playChip()
                        msg = "Bet changed"
                    elseif action == "CENTER" then
                        msg = spin(p)
                        break -- Turn done
                    elseif action == "RIGHT" then
                        -- Player leaving?
                        allQuit = true
                        break
                    end
                end
                if allQuit then break end
            end
            
            if allQuit then break end
        end
        
        -- Unlock cards
        for _, p in ipairs(players) do
            creditsAPI.unlock(p.mountPath)
        end
    end
end

main()

]])

writeFile('startup.lua', [[
-- startup.lua
-- Launches the Arcade Menu OS

-- Monitor Detection
local monitor = peripheral.find("monitor")
if monitor then
    term.redirect(monitor)
    
    -- Dynamic Scaling: Find largest text scale that fits the UI
    local min_w, min_h = 39, 19 -- Minimum resolution for Arcade apps
    
    for scale = 5, 0.5, -0.5 do
        monitor.setTextScale(scale)
        local w, h = monitor.getSize()
        if w >= min_w and h >= min_h then
            break
        end
    end
end

term.clear()
term.setCursorPos(1, 1)
print("Booting ArcadeOS...")

if not fs.exists(".button_config") then
    shell.run("config.lua")
end

print("Press 'D' for Dev Mode (2s)...")

_G.ARCADE_DEV_MODE = false
local timer = os.startTimer(2)
while true do
    local event, p1 = os.pullEvent()
    if event == "timer" and p1 == timer then
        break
    elseif event == "char" and p1:lower() == "d" then
        _G.ARCADE_DEV_MODE = true
        print("DEV MODE ENABLED: Infinite Credits")
        sleep(1)
        break
    end
end

if not _G.ARCADE_DEV_MODE then
    print("Production Mode: Standard Credits")
end
sleep(0.5)

if fs.exists(".arcade_config") then
    local file = fs.open(".arcade_config", "r")
    local cmd = file.readAll()
    file.close()
    
    -- Trim whitespace just in case
    cmd = cmd:gsub("%s+", "")
    
    if fs.exists(cmd .. ".lua") then
        print("Launching " .. cmd .. "...")
        sleep(0.5)
        shell.run(cmd)
    else
        print("Error: Configured game '" .. cmd .. "' not found!")
        print("Delete .arcade_config to reset.")
    end
elseif fs.exists("setup.lua") then
    shell.run("setup.lua")
else
    print("Error: setup.lua not found!")
end

]])


print('Installation Complete!')
print('Rebooting in 2 seconds...')
sleep(2)
os.reboot()

