$outputFile = "install.lua"

$header = @'
-- Arcade OS Installer
-- Generated by bundle.ps1

local function ensureDirForPath(path)
    local dir = fs.getDir(path)
    if dir and dir ~= '' and not fs.exists(dir) then
        fs.makeDir(dir)
    end
end

local function writeFile(path, content)
    ensureDirForPath(path)
    local file = fs.open(path, 'w')
    file.write(content)
    file.close()
    print('Installed: ' .. path)
end

print('Installing Arcade OS...')

'@

$sb = New-Object System.Text.StringBuilder
$null = $sb.Append($header)

$root = (Get-Location).Path
$files = Get-ChildItem -Recurse -Filter "*.lua" -File |
    Where-Object { $_.FullName -ne (Join-Path $root "install.lua") -and $_.FullName -ne (Join-Path $root "bundle.ps1") } |
    Sort-Object FullName

foreach ($file in $files) {
    $content = Get-Content -Path $file.FullName -Raw -Encoding UTF8

    $relativePath = $file.FullName.Substring($root.Length).TrimStart('\','/')
    $relativePath = $relativePath -replace "\\", "/"
    
    # Determine appropriate delimiter
    $level = 0
    $open = "[" + "=" * $level + "["
    $close = "]" + "=" * $level + "]"
    
    while ($content.Contains($close)) {
        $level++
        $open = "[" + "=" * $level + "["
        $close = "]" + "=" * $level + "]"
    }
    
    $luaBlock = "writeFile('$relativePath', $open`n$content`n$close)" + "`n`n"
    $null = $sb.Append($luaBlock)
}

$footer = @'

-- Optional: set default game for this machine
local function readExistingArcadeConfig()
    if not fs.exists('.arcade_config') then return nil end
    local f = fs.open('.arcade_config', 'r')
    if not f then return nil end
    local cmd = (f.readAll() or '')
    f.close()
    cmd = cmd:gsub('%s+', '')
    if cmd == '' then return nil end
    return cmd
end

local function writeArcadeConfig(cmd)
    local f = fs.open('.arcade_config', 'w')
    f.write(cmd)
    f.close()
end

local function deleteArcadeConfig()
    if fs.exists('.arcade_config') then fs.delete('.arcade_config') end
end

local function configureDefaultGame()
    local existing = readExistingArcadeConfig()
    print('')
    print('DEFAULT GAME CONFIG')
    print('===================')
    print('Current: ' .. tostring(existing or '<none>'))
    print('')
    print('Pick a default game for this computer.')
    print('(Press Enter to keep current.)')
    print('')

    local options = {
        { name = 'Arcade Menu (admin key required if kiosk)', cmd = 'menu' },
        { name = "Can't Stop (Free)", cmd = 'cant_stop' },
        { name = 'Horse Race', cmd = 'race' },
        { name = 'Super Slots', cmd = 'slots' },
        { name = 'Blackjack', cmd = 'blackjack' },
        { name = 'Baccarat', cmd = 'baccarat' },
        { name = 'RPS Rogue', cmd = 'rps_rogue' },
        { name = 'Roulette Watch', cmd = 'screensavers/roulette' },
        { name = 'Exchange', cmd = 'exchange' },
        { name = 'Cashier System', cmd = 'cashier' }
    }

    for i, opt in ipairs(options) do
        print(tostring(i) .. ') ' .. opt.name .. '  [' .. opt.cmd .. ']')
    end
    print('')
    print("Type a number, or type a command, or type 'none' to clear:")
    write('> ')
    local choice = read()
    choice = (choice or ''):gsub('%s+', '')

    if choice == '' then
        return
    end
    if choice == 'none' then
        deleteArcadeConfig()
        print('Cleared .arcade_config')
        return
    end

    local idx = tonumber(choice)
    local cmd = nil
    if idx and options[idx] then
        cmd = options[idx].cmd
    else
        cmd = choice
    end

    writeArcadeConfig(cmd)
    print('Set .arcade_config to: ' .. cmd)
    print('')
    print("Note: configured machines run in kiosk mode by default.")
    print("Insert a disk containing 'admin.key' to bypass kiosk.")
end

print('Installation Complete!')
configureDefaultGame()
print('Rebooting in 2 seconds...')
sleep(2)
os.reboot()
'@

$null = $sb.Append($footer)

$utf8NoBom = New-Object System.Text.UTF8Encoding($false)
[System.IO.File]::WriteAllText($outputFile, $sb.ToString(), $utf8NoBom)

Write-Host "Build complete: $outputFile"
